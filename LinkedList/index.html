<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--><!--[if gt IE 8]><!--><html class="no-js">
<!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <title>Java源码分析——LinkedList – WorkHard-Website</title> <meta name="description" content="This is my own site."> <meta name="keywords" content="JavaBasic"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="https://ckape.github.io/workhard//assets/img/logo.png"> <meta name="twitter:title" content="Java源码分析——LinkedList"> <meta name="twitter:description" content="LinkedList源码分析."> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="Java源码分析——LinkedList"> <meta property="og:description" content="LinkedList源码分析."> <meta property="og:url" content="https://ckape.github.io/workhard//LinkedList/"> <meta property="og:site_name" content="WorkHard-Website"> <meta property="og:image" content="https://ckape.github.io/workhard//assets/img/logo.png"> <link rel="canonical" href="https://ckape.github.io/workhard//LinkedList/"> <link href="https://ckape.github.io/workhard//feed.xml" type="application/atom+xml" rel="alternate" title="WorkHard-Website Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="https://ckape.github.io/workhard//assets/css/main.css"> <!-- JS --> <script src="https://ckape.github.io/workhard//assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="https://ckape.github.io/workhard//assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="https://ckape.github.io/workhard//assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="https://ckape.github.io/workhard//assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="https://ckape.github.io/workhard//assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="https://ckape.github.io/workhard//favicon.png"> <link rel="shortcut icon" href="https://ckape.github.io/workhard//favicon.ico"> <!-- Background Image --> <style type="text/css">body {background-image:url(https://ckape.github.io/workhard//assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="https://ckape.github.io/workhard//">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="https://ckape.github.io/workhard//assets/img/logo.png" alt="WorkHard-Website photo" class="author-photo"> <h4>WorkHard-Website</h4> <p>This is my own site.</p> </li> <li><a href="https://ckape.github.io/workhard//about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:kape520@163.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/ckape" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul>
<!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="https://ckape.github.io/workhard//posts/">All Posts</a></li> <li><a href="https://ckape.github.io/workhard//tags/">All Tags</a></li> </ul> </li> <li><a href="https://ckape.github.io/workhard//projects/">Projects</a></li> </ul>
<!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title "> <h1>Java源码分析——LinkedList</h1> <h4>20 Sep 2016</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~9 minutes </p>
<!-- /.entry-reading-time --> <a class="btn zoombtn" href="https://ckape.github.io/workhard//posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <p>#LinkedList</p> <blockquote> <p>参考学习资料：</p> <blockquote> <p>JDK1.7之前的【Java集合源码剖析】LinkedList源码剖析</p> </blockquote> </blockquote> <ol> <li>LinkedList的要点 <ul> <li>
<strong>双向链表</strong>：LinkedList基于双向链表实现的（Entry有next，previous指针），因此可以把它当栈，队列和双端队列使用； 在JDK1.7之前LinkedList之前是循环链表的方式实现两端插入的，包含一个无值的头结点，JDK1.7及以上是包含两个指针分别指向头结点和尾结点；</li> <li>
<strong>线程不安全</strong>：LinkedList通过维护modCount修改计数，每个迭代器保存各自的修改计数与modCount对比检验的方式防止并发修改；</li> <li>
<strong>性能特点</strong>：由于是链表实现，不支持快速随机存取，因此get(index)效率不高，在循环时一定注意不能误用；支持高效的结构性修改（只需要移动指针指向）；因此LinkedList定义了内部类实现ListIterator，避免使用效率低下的get()（AbstractList的迭代器是基于get()的），iterator()返回也是这个内部类实例；</li> <li>
<strong>克隆和序列化</strong>：实现了Serializable和Cloneable接口，支持序列化和克隆，其中序列化使用writeObject和readObject不采用默认的序列化机制，只保存size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销；</li> <li>
<strong>置空操作</strong>：强调一点，对应容器，删除结点时x = null;是很有必要的，让容器，容器中的结点在清除后不要互相引用的保存在堆中，影响垃圾回收，因为JVM一般是进行可达性分析的；</li> </ul> </li> <li>基本结构 <ul> <li>结点类 <ul> <li>双向链表，链表包含2个指针：头结点指针，尾结点指针；</li> <li>结点（Node），包含2个指针，指向前驱结点和后序结点； <div class="language-java highlighter-rouge"><pre class="highlight"><code> <span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    
 <span class="c1">//不变式：(first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null)</span>
 <span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
 <span class="c1">//不变式：(first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null)</span>
 <span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">last</span><span class="o">;</span>
 <span class="c1">//结点</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
   <span class="n">E</span> <span class="n">item</span><span class="o">;</span>
   <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
   <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>
   <span class="n">Node</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">,</span> <span class="n">E</span> <span class="n">element</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">this</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
       <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
       <span class="k">this</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
   <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div> </li> </ul> </li> <li>列表迭代器ListIterator非静态内部类实现 <ul> <li>每个迭代器对象独立维护一个expectedModCount进行修改计数检查，每次进行修改操作之前（包括set方法）检查计数，防止并发修改（抛出ConcurrentModificationException异常）；</li> <li>lastReturned这个变量很关键，结构性修改一次之后（add和remove）这个变量被置空，因此对于迭代器调用一次add或remove之后调用next才可以在此remove和set；</li> <li>ListIterator支持两个方向的迭代遍历； <div class="language-java highlighter-rouge"><pre class="highlight"><code> <span class="kd">private</span> <span class="kd">class</span> <span class="nc">ListItr</span> <span class="kd">implements</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
   <span class="c1">//lastReturned保存最后返回的结点引用，当add，remove结构性修改后将这个值置空用于标识结构结构已修改</span>
   <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">lastReturned</span><span class="o">;</span>
   <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">nextIndex</span><span class="o">;</span>
   <span class="c1">//每个迭代器保存创建时modCount，维护自己的modCount防止因为并发修改造成的不一致</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
   <span class="n">ListItr</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">size</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">node</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
       <span class="n">nextIndex</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">//每次结构性修改之前必须先检查modCount是否同步，保证同时只有一个ListIterator可以修改链表</span>
       <span class="n">checkForComodification</span><span class="o">();</span>
       <span class="c1">//lastReturned置空，防止删除之前的结点</span>
       <span class="n">lastReturned</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
       <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
           <span class="n">linkLast</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
       <span class="k">else</span>
           <span class="nf">linkBefore</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
       <span class="n">nextIndex</span><span class="o">++;</span>
       <span class="n">expectedModCount</span><span class="o">++;</span>
   <span class="o">}</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">nextIndex</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="n">E</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
       <span class="c1">//检查修改计数</span>
       <span class="n">checkForComodification</span><span class="o">();</span>
       <span class="k">if</span><span class="o">(!</span><span class="n">hasNext</span><span class="o">())</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
       <span class="n">lastReturned</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
       <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
       <span class="n">nextIndex</span><span class="o">++;</span>
       <span class="k">return</span> <span class="n">lastReturned</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPrevious</span><span class="o">()</span> <span class="o">{</span>
       <span class="c1">//nextIndex时显然不能有prev</span>
       <span class="k">return</span> <span class="n">nextIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="c1">//前一个结点，此时next和lastReturned值一致</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="n">E</span> <span class="nf">previous</span><span class="o">()</span> <span class="o">{</span>
       <span class="n">checkForComodification</span><span class="o">();</span>
       <span class="k">if</span><span class="o">(!</span><span class="n">hasPrevious</span><span class="o">())</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
       <span class="n">nextIndex</span><span class="o">--;</span>
       <span class="n">lastReturned</span> <span class="o">=</span> <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">last</span> <span class="o">:</span> <span class="n">next</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
       <span class="k">return</span> <span class="n">lastReturned</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">nextIndex</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">nextIndex</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">previousIndex</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">return</span> <span class="n">nextIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="c1">//删除最后返回的结点</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
       <span class="c1">//检查修改计数</span>
       <span class="n">checkForComodification</span><span class="o">();</span>
       <span class="k">if</span><span class="o">(</span><span class="n">lastReturned</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">();</span>

       <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">lastNext</span> <span class="o">=</span> <span class="n">lastReturned</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
       <span class="n">unlink</span><span class="o">(</span><span class="n">lastReturned</span><span class="o">);</span>
       <span class="c1">//如果next和lastReturned（这种情况在previous执行后出现），要修改next值</span>
       <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">lastReturned</span><span class="o">)</span>
           <span class="n">next</span> <span class="o">=</span> <span class="n">lastNext</span><span class="o">;</span> <span class="c1">//虽然删除了一个结点，但是next向后移动了一位，因此nextIndex值不需要修改</span>
       <span class="k">else</span>
           <span class="n">nextIndex</span><span class="o">--;</span>
       <span class="n">lastReturned</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
       <span class="n">expectedModCount</span><span class="o">++;</span>
   <span class="o">}</span>
   <span class="c1">//修改最后返回结点的值</span>
   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
       <span class="k">if</span><span class="o">(</span><span class="n">lastReturned</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">();</span>
       <span class="n">checkForComodification</span><span class="o">();</span>
       <span class="n">lastReturned</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="c1">//检查是否并发修改</span>
   <span class="kd">final</span> <span class="kt">void</span> <span class="nf">checkForComodification</span><span class="o">()</span> <span class="o">{</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
   <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div> </li> </ul> </li> </ul> </li> <li>操作：LinkedList继承自AbstractSequentialList，实现了List，Deque，Serializable和Cloneable；因此可以按此顺序进行解释，首先分析LinkedList自身最很核心的方法。 <ul> <li>3-1 核心操作：包括linkFirst，linkLast，linkBefore，unlink，unlinkFirst，unlinkLast，node；这7个方法实现了双向链表最核心的功能，其他接口实现大部分是基于这7个方法的。</li> <li>3-1-1. 这些方法有几个重要的细节： <ul> <li>i. 删除结点的时候置空操作；</li> <li>ii. modCount的修改；</li> <li>iii. node方法查找某个位置的结点根据index和size/2的关系进行优化处理； <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">//在头端插入</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">linkFirst</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">f</span><span class="o">);</span>
  <span class="n">first</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">f</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//原链表为空时last指针也要指向新结点</span>
      <span class="n">last</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">f</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">++</span><span class="n">size</span><span class="o">;</span>
  <span class="c1">//增加修改次数</span>
  <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//在尾端插入</span>
<span class="kt">void</span> <span class="nf">linkLast</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">e</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
  <span class="n">last</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//原链表为空时first指针也要执行新结点</span>
      <span class="n">first</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">l</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">++</span><span class="n">size</span><span class="o">;</span>
  <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//在指定结点前插入</span>
<span class="kt">void</span> <span class="nf">linkBefore</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">succ</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">e</span><span class="o">,</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">,</span> <span class="n">succ</span><span class="o">);</span>
  <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">first</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">++</span><span class="n">size</span><span class="o">;</span>
  <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//删除第一个结点，由调用者判断是否有头结点</span>
<span class="kd">private</span> <span class="n">E</span> <span class="nf">unlinkFirst</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">E</span> <span class="n">element</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
  <span class="n">f</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//删除之后置为null，不影响被引用对象的垃圾回收</span>
  <span class="n">f</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="n">first</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span> <span class="c1">//first指针指向next</span>
  <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
      <span class="n">last</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">else</span>
      <span class="n">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">--</span><span class="n">size</span><span class="o">;</span> <span class="c1">//数量减少</span>
  <span class="o">++</span><span class="n">modCount</span><span class="o">;</span> <span class="c1">//修改计数增加</span>
  <span class="k">return</span> <span class="n">element</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//删除最后一个结点</span>
<span class="kd">private</span> <span class="n">E</span> <span class="nf">unlinkLast</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">E</span> <span class="n">element</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
  <span class="n">l</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//置空不影响原被引用对象的垃圾回收</span>
  <span class="n">l</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="n">last</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
  <span class="k">if</span><span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
      <span class="n">first</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">else</span>
      <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">--</span><span class="n">size</span><span class="o">;</span>
  <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">element</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//删除链表中某个结点</span>
<span class="n">E</span> <span class="nf">unlink</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
  <span class="kd">final</span> <span class="n">E</span> <span class="n">element</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
  <span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">//置空，不影响垃圾回收</span>
  <span class="k">if</span><span class="o">(</span><span class="n">prev</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
      <span class="n">first</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
  <span class="k">else</span> <span class="o">{</span>
      <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
      <span class="n">x</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
      <span class="n">last</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
  <span class="k">else</span> <span class="o">{</span>
      <span class="n">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
      <span class="n">x</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="o">--</span><span class="n">size</span><span class="o">;</span>
  <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">element</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">//获取指定位置的结点，通过index是否小于size/2进行优化</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">node</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">//如果小于size / 2从头开始搜索，否则从尾开始搜索</span>
  <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
          <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">--</span><span class="n">i</span><span class="o">)</span>
          <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div> </li> </ul> </li> <li>3-2 私有辅助方法：包括检查查找索引，插入位置是否合法； <div class="language-java highlighter-rouge"><pre class="highlight"><code> <span class="c1">//检查索引是否合法</span>
 <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isElementIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">//检查索引是否合法，不合法抛出异常</span>
 <span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkElementIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">if</span><span class="o">(</span><span class="n">isElementIndex</span><span class="o">(</span><span class="n">index</span><span class="o">))</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfBoundsException</span><span class="o">(</span><span class="n">outOfBoundsMsg</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
 <span class="o">}</span>
 <span class="kd">private</span> <span class="n">String</span> <span class="nf">outOfBoundsMsg</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="s">"Index: "</span><span class="o">+</span><span class="n">index</span><span class="o">+</span><span class="s">", Size: "</span><span class="o">+</span><span class="n">size</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">//检查待插入位置的索引值是否合法</span>
 <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isPositionIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">return</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">//检查待插入位置的索引值是否合法，不合法抛出异常</span>
 <span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkPositionIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
     <span class="k">if</span><span class="o">(</span><span class="n">isPositionIndex</span><span class="o">(</span><span class="n">index</span><span class="o">))</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">IndexOutOfBoundsException</span><span class="o">(</span><span class="n">outOfBoundsMsg</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
 <span class="o">}</span>
</code></pre></div> </li> </ul> </li> </ol> <ul> <li>3-3 List接口实现 <ul> <li>3-3-1 基于Node内部表示，因此List的关键方法也要依赖与内部表示；</li> <li>3-3-2 注意，LinkedList的subList实现没有覆盖AbstractList的实现； <div class="language-java highlighter-rouge"><pre class="highlight"><code>  <span class="c1">//添加结点，在表尾</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">linkLast</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//在指定位置添加结点</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">E</span> <span class="n">element</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//检查插入位置是否合法</span>
      <span class="n">checkPositionIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>

      <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">size</span><span class="o">)</span> <span class="c1">//排除为空的可能</span>
          <span class="n">linkLast</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
      <span class="k">else</span> <span class="o">{</span> <span class="c1">//index &lt; size时</span>
          <span class="n">linkBefore</span><span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">node</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
      <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">//将一个集合中元素添加在指定位置之后，注意双向链表中指针值的设置</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//检验插入位置是否合法</span>
      <span class="n">checkPositionIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>

      <span class="c1">//将这个集合中的保存到新数组中，再进行操作，这是一种“安全”的做法</span>
      <span class="c1">//使用toArray的目的是为了调用者可以自由的操作这个数组，而不会影响原来的集合</span>
      <span class="c1">//返回的是对象数组，因为将集合类本身并不知道具体是什么类型，因此无法以最具体的类型声明数组</span>
      <span class="c1">//调用此方法也意味着我们要进行强制类型转换，不过可以像addAll这样通过参数的类型参数来限制保证正确的类型</span>
      <span class="n">Object</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
      <span class="kt">int</span> <span class="n">numNew</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">//arraylength指令（乱入一记字节码指令）</span>
      <span class="k">if</span><span class="o">(</span><span class="n">numNew</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
          <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

      <span class="c1">//声明两个变量（指针）用来辅助设置插入过程中前后结点的指针值</span>
      <span class="c1">//保存succ最后修改这个结点的prev指针（如果不为空的话）</span>
      <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">pred</span><span class="o">,</span> <span class="n">succ</span><span class="o">;</span>
      <span class="c1">//插入位置正好是末尾，无法通过node()查找定位到</span>
      <span class="c1">//否则找到index位置的结点，并确定pred的值</span>
      <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">pred</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
          <span class="n">succ</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">succ</span> <span class="o">=</span> <span class="n">node</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
          <span class="n">pred</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="k">for</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
          <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span> <span class="n">E</span> <span class="n">element</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span><span class="n">o</span><span class="o">;</span>
          <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="n">element</span><span class="o">,</span> <span class="n">pred</span><span class="o">,</span> <span class="n">succ</span><span class="o">);</span>
          <span class="k">if</span><span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">//在表头插入，设置frist值</span>
              <span class="n">first</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
          <span class="k">else</span>
              <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
          <span class="n">pred</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">//设置后续结点的prev</span>
      <span class="k">if</span><span class="o">(</span><span class="n">succ</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">//在末尾插入修改last的指向</span>
          <span class="n">last</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
      <span class="k">else</span> <span class="o">{</span>
          <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
          <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="n">size</span> <span class="o">+=</span> <span class="n">numNew</span><span class="o">;</span>
      <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>

      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">addAll</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//检验索引值是否合法，不合法抛出异常</span>
      <span class="n">checkElementIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
      <span class="k">return</span> <span class="nf">node</span><span class="o">(</span><span class="n">index</span><span class="o">).</span><span class="na">item</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//设置并返回旧值</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">E</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">E</span> <span class="n">element</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//检验索引值是否合法，不合法抛出异常</span>
      <span class="n">checkElementIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
      <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">node</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
      <span class="n">E</span> <span class="n">oldVal</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
      <span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">oldVal</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">E</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">checkElementIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
      <span class="k">return</span> <span class="nf">unlink</span><span class="o">(</span><span class="n">node</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                  <span class="n">unlink</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
              <span class="o">}</span>
          <span class="o">}</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">if</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">))</span> <span class="o">{</span>
                  <span class="n">unlink</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                  <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
              <span class="o">}</span>
          <span class="o">}</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//清空链表，尤其注意置空，让结点之间，结点和元素之间不在互相引用的存在堆中，让它们“独立”的接受垃圾回收</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;)</span> <span class="o">{</span>
          <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
          <span class="c1">//置空，不要影响原来被引用对象的垃圾回收</span>
          <span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
          <span class="n">x</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
          <span class="n">x</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
          <span class="n">x</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">first</span> <span class="o">=</span> <span class="n">last</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//查找指定对象第一次出现的位置</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="k">if</span><span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                  <span class="k">return</span> <span class="n">index</span><span class="o">;</span>
              <span class="n">index</span><span class="o">++;</span>
          <span class="o">}</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">if</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">))</span>
                  <span class="k">return</span> <span class="n">index</span><span class="o">;</span>
              <span class="n">index</span><span class="o">++;</span>
          <span class="o">}</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//查找指定对象最后一次出现的位置</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">lastIndexOf</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

      <span class="k">if</span><span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                  <span class="k">return</span> <span class="n">index</span><span class="o">;</span>
              <span class="n">index</span><span class="o">++;</span>
          <span class="o">}</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">if</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">))</span>
                  <span class="k">return</span> <span class="n">index</span><span class="o">;</span>
              <span class="n">index</span><span class="o">++;</span>
          <span class="o">}</span>
      <span class="o">}</span>

      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//注意contains，indexOf，lastIndexOf方法接受的都是Object</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">indexOf</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//列表迭代器</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">listIterator</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">checkPositionIndex</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">ListItr</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">//保存为数组，这里只能返回Object，因为不能通过泛型参数创建对象/数组对象</span>
  <span class="c1">//通过toArray方法可以自由操作该集合内元素而不影响该集合</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">Object</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
      <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">//toArray的泛型方法版本，相对于toArray()来说可以进行必要的类型检查，但是创建数组的责任交给了调用者</span>
  <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">//检查长度是否能够存放所有元素</span>
      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">)</span> <span class="c1">//小于size重新通过反射创建</span>
          <span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="n">T</span><span class="o">[])</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">reflect</span><span class="o">.</span><span class="na">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span>
                  <span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getComponentType</span><span class="o">(),</span> <span class="n">size</span><span class="o">);</span>

      <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="c1">//通过Object数组引用，可以避开泛型参数的限制，数组对象本身可以检查存入的类型是否正确，不正确保存ArrayStoreException</span>
      <span class="n">Object</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
      <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">++]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">//如果数组长度大于集合长度，size位置置空</span>
      <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">a</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div> </li> </ul> </li> <li>3-4 Deque双端队列的实现 <ul> <li>3-4-1 与其他队列实现一样：offer（入队），poll（出队），peek（队首元素）不抛出异常，remove～（不同位置的删除方法），element（队首元素）为空是抛出异常；</li> <li>3-4-2 现pop和push，栈操作，以链表头作为栈顶； <div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">linkFirst</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">linkLast</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offerFirst</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addFirst</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offerLast</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addLast</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">removeFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">f</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">(</span><span class="s">"first is not exist."</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">unlinkFirst</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">removeLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">(</span><span class="s">"last is not exist."</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">unlinkLast</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//poll~方法不抛出异常，为空时返回null</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">pollFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">f</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">unlinkFirst</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">pollLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">l</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">unlinkLast</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//get~方法抛出异常</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">f</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">l</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">peekFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">f</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">f</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">peekLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">l</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">l</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//删除队列中第一个该对象的引用</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">removeFirstOccurrence</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">remove</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//删除队列中最后一个该对象的引用</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">removeLastOccurrence</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">unlink</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">unlink</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//入队操作，链表尾部插入，不抛出异常</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//出队操作，不抛出异常</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">f</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">unlinkFirst</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//获取表头元素，栈的操作，不抛出异常</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">f</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">f</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//出队删除，检查抛出异常</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">removeFirst</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">//获取表头元素，抛出异常</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">element</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getFirst</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">//入栈，表头添加，栈的操作</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addFirst</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//出栈，表头删除，栈的操作</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">E</span> <span class="nf">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">removeFirst</span><span class="o">();</span>
    <span class="o">}</span>
</code></pre></div> </li> </ul> </li> <li>3-5 AbstractSequentialList的实现（实现逆序迭代器）。 <div class="language-java highlighter-rouge"><pre class="highlight"><code>      <span class="c1">//逆序迭代器</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">descendingIterator</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">DescendingIterator</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="kd">private</span> <span class="kd">class</span> <span class="nc">DescendingIterator</span> <span class="kd">implements</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
          <span class="kd">private</span> <span class="kd">final</span> <span class="n">ListItr</span> <span class="n">itr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListItr</span><span class="o">(</span><span class="n">size</span><span class="o">());</span>
          <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
              <span class="k">return</span> <span class="n">itr</span><span class="o">.</span><span class="na">hasPrevious</span><span class="o">();</span>
          <span class="o">}</span>
          <span class="kd">public</span> <span class="n">E</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
              <span class="k">return</span> <span class="n">itr</span><span class="o">.</span><span class="na">previous</span><span class="o">();</span>
          <span class="o">}</span>
          <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
              <span class="n">itr</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
          <span class="o">}</span>
      <span class="o">}</span>
</code></pre></div> </li> <li>3-6 Cloneable的实现 <div class="language-java highlighter-rouge"><pre class="highlight"><code>      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
          <span class="n">MLinkedList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">clone</span> <span class="o">=</span> <span class="n">superClone</span><span class="o">();</span>
          <span class="n">clone</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">clone</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
          <span class="n">clone</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
          <span class="n">clone</span><span class="o">.</span><span class="na">modCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

          <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">clone</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">);</span>
          <span class="o">}</span>

          <span class="k">return</span> <span class="n">clone</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
      <span class="kd">private</span> <span class="n">MLinkedList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">superClone</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">try</span> <span class="o">{</span>
              <span class="k">return</span> <span class="o">(</span><span class="n">MLinkedList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;)</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nf">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
          <span class="o">}</span>
      <span class="o">}</span>
</code></pre></div> </li> <li>3-7 序列化支持 <ul> <li>3-7-1 LinkedList的size，first，last使用transient关键字，使用自定义的序列化机制，只写入size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销；</li> <li>3-7-2 在JDK1.7之前使用的并不是Node而是Entry，也是保存了元素对象而不是Entry，这样的考虑解决了LinkedList的兼容问题； <div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="c1">//序列化版本号，是数据域和方法签名的数字指纹（SHA）</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">876323262645176354L</span><span class="o">;</span>

    <span class="c1">//代替默认的序列化过程，这里值写入了元素对象和元素集合大小</span>
    <span class="c1">//在JDK1.7之前使用的并不是Node而是Entry，也是保存了元素对象而不是Entry，这样的考虑解决了LinkedList的兼容问题</span>
    <span class="c1">//这也是为什么用transient修饰size，first，last域的原因</span>
    <span class="c1">//一方面是隐藏内部表示信息，一方面节省了开销</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">writeObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectOutputStream</span> <span class="n">s</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="c1">//写入包括魔数，序列化格式版本号，包括所有对象的类型和（非静态和非transient）数据域</span>
        <span class="c1">//每个对象包括一个序列号</span>
        <span class="c1">//相同对象重复出现将被视为对这个对象序列号的引用</span>
        <span class="n">s</span><span class="o">.</span><span class="na">defaultWriteObject</span><span class="o">();</span>

        <span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">s</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">item</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">//反序列化过程，同样读取size和元素对象，重新“构建”链表</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">defaultReadObject</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">linkLast</span><span class="o">((</span><span class="n">E</span><span class="o">)</span><span class="n">s</span><span class="o">.</span><span class="na">readObject</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div> <ol> <li>LinkedList对Java 8新特性的支持（例如对Lambda表达式的支持）</li> </ol> </li> </ul> </li> </ul> <ol> <li>总结： <ul> <li>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</li> <li>LinkedList 实现 List 接口，能对它进行队列操作。</li> <li>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</li> <li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。</li> <li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</li> <li>LinkedList 是非同步的。</li> </ul> </li> </ol> <ul> <li>LinkedList的本质是双向链表。</li> <li>LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。</li> <li>LinkedList包含两个重要的成员：header 和 size。 　　+ header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。 　　+ size是双向链表中节点的个数。</li> <li>LinkedList 实际上是通过双向链表去实现的。 它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。</li> <li>从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。</li> <li>LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。</li> <li>LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。</li> <li>由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</li> <li>LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价：</li> </ul> <table> <thead> <tr> <th>队列方法</th> <th style="text-align: center">等效方法</th> </tr> <tr> <th>add(e)</th> <th style="text-align: center">addLast(e)</th> </tr> </thead> <tbody> <tr> <td>offer(e)</td> <td style="text-align: center">offerLast(e)</td> </tr> <tr> <td>remove()</td> <td style="text-align: center">removeFirst()</td> </tr> <tr> <td>poll()</td> <td style="text-align: center">pollFirst()</td> </tr> <tr> <td>element()</td> <td style="text-align: center">getFirst()</td> </tr> <tr> <td>peek()</td> <td style="text-align: center">peekFirst()</td> </tr> </tbody> </table> <ul> <li>LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价：</li> </ul> <table> <thead> <tr> <th>栈方法</th> <th style="text-align: center">等效方法</th> </tr> </thead> <tbody> <tr> <td>push(e)</td> <td style="text-align: center">addFirst(e)</td> </tr> <tr> <td>pop()</td> <td style="text-align: center">removeFirst()</td> </tr> <tr> <td>peek()</td> <td style="text-align: center">peekFirst()</td> </tr> </tbody> </table> <p><strong>与Stack比较</strong></p> <p>Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。 java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在“Java 集合系列06之 Vector详细介绍(源码解析)和使用示例”中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。</p> <ol> <li>Stack实际上也是通过数组去实现的。 执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。 执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。 执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。</li> <li>Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。</li> </ol> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="https://ckape.github.io/workhard//tags/#JavaBasic" title="Pages tagged JavaBasic" class="tag"><span class="term">JavaBasic</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=https://ckape.github.io/workhard//LinkedList/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Like</span> </a> <a href="https://twitter.com/intent/tweet?text=https://ckape.github.io/workhard//LinkedList/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=https://ckape.github.io/workhard//LinkedList/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> </header> <!-- JS --> <script src="https://ckape.github.io/workhard//assets/js/jquery-1.12.0.min.js"></script> <script src="https://ckape.github.io/workhard//assets/js/jquery.dlmenu.min.js"></script> <script src="https://ckape.github.io/workhard//assets/js/jquery.goup.min.js"></script> <script src="https://ckape.github.io/workhard//assets/js/jquery.magnific-popup.min.js"></script> <script src="https://ckape.github.io/workhard//assets/js/jquery.fitvid.min.js"></script> <script src="https://ckape.github.io/workhard//assets/js/scripts.js"></script> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
