<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--><!--[if gt IE 8]><!--><html class="no-js">
<!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> <title>Test – WorkHard-Website</title> <meta name="description" content="This is my own site."> <meta name="keywords" content="test"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="http://127.0.0.1:4000//assets/img/logo.png"> <meta name="twitter:title" content="Test"> <meta name="twitter:description" content="The first pages."> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="Test"> <meta property="og:description" content="The first pages."> <meta property="og:url" content="http://127.0.0.1:4000//test/"> <meta property="og:site_name" content="WorkHard-Website"> <meta property="og:image" content="http://127.0.0.1:4000//assets/img/logo.png"> <link rel="canonical" href="http://127.0.0.1:4000//test/"> <link href="http://127.0.0.1:4000//feed.xml" type="application/atom+xml" rel="alternate" title="WorkHard-Website Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="http://127.0.0.1:4000//assets/css/main.css"> <!-- JS --> <script src="http://127.0.0.1:4000//assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="http://127.0.0.1:4000//assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="http://127.0.0.1:4000//assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="http://127.0.0.1:4000//assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="http://127.0.0.1:4000//assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="http://127.0.0.1:4000//favicon.png"> <link rel="shortcut icon" href="http://127.0.0.1:4000//favicon.ico"> <!-- Background Image --> <style type="text/css">body {background-image:url(http://127.0.0.1:4000//assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="http://127.0.0.1:4000//">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="http://127.0.0.1:4000//assets/img/logo.png" alt="WorkHard-Website photo" class="author-photo"> <h4>WorkHard-Website</h4> <p>This is my own site.</p> </li> <li><a href="http://127.0.0.1:4000//about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="mailto:kape520@163.com" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-envelope-square"></i> Email</a> </li> <li> <a href="http://github.com/ckape" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul>
<!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="http://127.0.0.1:4000//posts/">All Posts</a></li> <li><a href="http://127.0.0.1:4000//tags/">All Tags</a></li> </ul> </li> <li><a href="http://127.0.0.1:4000//projects/">Projects</a></li> </ul>
<!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title "> <h1>Test</h1> <h4>20 Sep 2016</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~15 minutes </p>
<!-- /.entry-reading-time --> <a class="btn zoombtn" href="http://127.0.0.1:4000//posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <h2 id="list">List</h2> <ul> <li>ArrayList（常用） Implemented Interfaces:Serializable,Cloneable,Iterable<e>,Collection<e>,List<e>,RandomAccess</e></e></e>
</li> <li>LinkedList（常用） Implemented Interfaces:Serializable,Cloneable,Iterable<e>,Collection<e>,Deque<e>,List<e>,Queue<e></e></e></e></e></e>
</li> <li>Stack（了解）</li> <li>CopyOnWriteArrayList</li> <li>AbstractList</li> <li>AbstractSequentialList</li> <li>AttributeList</li> <li>RoleList</li> <li>RoleUnresolvedList</li> <li>Vector</li> </ul> <h2 id="arraylistarraylist">ArrayList（ArrayList中的操作不是线程安全的）</h2> <p><code class="highlighter-rouge">modCount</code>: The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.（已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。）</p> <ol> <li>ArrayList要点 （1）基于数组实现：内部表示通过控制对象数组的访问，数组是不能动态修改大小的，因此根据元素数量/指定容量大小，通过创建新数组，复制元素对象是ArrayList的核心原理之一； （2）性能特点：因为基于数组的，因此可以实现快速随机访问，比LinkedList效率高；但是增加/删除等需要通过复制数组元素（部分或全部）来实现，效率比LinkedList低； （3）线程不安全：同样使用modCount修改计数，类似乐观锁的fail-fast来防止并发修改带来的不一致，ArrayList的每个Iterator，ListIterator，SubList实例都独立维护一个基于ArrayList实例modCount的expectedModCount； （4）优化手段： 单例模式应用：EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA这两个单例的空数组对象，分别被“空状态”和“默认状态”的ArrayList共享； grow方法的增长机制：每次扩展数组的大小至少扩展到原数据的3/2大小，减少了创建新数组和复制动作的次数； （5）克隆和序列化：实现了Serializable和Cloneable接口，支持序列化和克隆，其中序列化使用writeObject和readObject不采用默认的序列化机制，只保存size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销； （6）防止内存泄漏的置空动作：维护一个数组也是自己维护内存管理，因为数组也持有这引用，删除时要及时置空不能影响GC活动，虽然LinkedList已经说了，再强调下；</li> <li>基本结构和操作 2.1 重要属性 //默认初始化容量 private static final int DEFAULT_CAPACITY = 10; /* 所有Empty数组列表共享一个空数组对象，不仅可以减少重复对象的创建（单例模式应用），还可以标识空列表状态 单例模式（区别于享元模式）： 一是这里只有一个对象； 二是不仅仅是节省内存，更重要的是起到共享并标识“空数组列表”的作用； EMPTY_ELEMENTDATA标识“空”状态，DEFAULTCAPACITY_EMPTY_ELEMENTDATA标识默认状态 <em>/ private static final Object[] EMPTY_ELEMENTDATA = {}; /</em> 默认状态创建数组列表实例使用该数组，使用一个单例空数组并且不直接使用EMPTY_ELEMENTDATA而是新键一个空数组的原因是： 一是用于标识不同的状态，区别于“空数组列表”，DEFAULTCAPACITY_EMPTY_ELEMENTDATA表示数组列表还未插入元素； 二是等到实际有元素再分配合适大小的数组内存空间，起到延迟加载的作用； 三是同样单例可以让所有默认状态列表使用一个空数组对象，节省内存； <em>/ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /</em> 使用transient的目的是为了隐藏内部表示 使用Object的原因： （1）Object可以引用所有具体类型的数组对象； （2）实际的ArrayList的类型参数对于ArrayList对象本身是不可知的，泛型的本质是擦除，并借助变量，方法，类的签名来进行类型检查和转换; 因此可以用Object数组存放元素对象，依赖方法和类型参数让编译器和JVM进行类型检查和转换（比如插入checkcast指令等等）； */ transient Object[] elementData; //元素个数 private int size;</li> </ol> <p>/* 翻译： 一些实现可能会保存一些首部信息在数组对象中。 试图分配一个比MAX_ARRAY_SIZE大的数组可能会造成OOM（Requested array size exceeds VM limit）。 也就是说一些JVM的实现可能会限制数组大小小于Integer.MAX_VALUE，因此检查是必要的。 <em>/ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 2.2 不同版本的构造器 这里可以看到在创建ArrayList对象实例的时候： （1）ArrayList()：默认状态，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA，这也是一个空数组，延迟加载，第一次插入时才分配内存； （2）如果指定的初始化容量为0,拷贝构造器传入集合为空，使用EMPTY_ELEMENTDATA； /</em> 不同版本的构造器 */ //如果指定初始化容量为“0”，使用EMPTY_ELEMENTDATA public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(“Illegal Capacity: “+ initialCapacity); } } //创建默认初始化容量列表，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; }</p> <p>//拷贝构造器，注意使用toArray获取要插入元素对象 public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if((size = elementData.length) != 0) { /* 注意，toArray返回的Object[]引用，而Object[]可以作为超类引用子类对象比如A[]（假设A是E的子类） 如果toArray返回是A[]数组对象，那么如果类型B对象（B extends E）可能会引起后续的插入时的ArrayStoreException，读取元素时的ClassCheckException 因此如果返回的不是Object[]对象，要创建一个Object[]并复制元素引用 */ if(elementData.getClass() != Object[].class) { elementData = Arrays.copyOf(elementData, size, Objects[].class); } } else { //一个空数组列表，直接使用EMPTY_ELEMENTDATA elementData = EMPTY_ELEMENTDATA; } } 2.3 核心操作 主要方法包括：trimToSize（压缩缓存数组），grow（扩展容量），ensure～（不同情况下调用的扩容方法），removeRange（范围删除），batchRemove（批量删除），fastRemove（基于复制的快速复制），这些方法供之后方法调用； //压缩缓存区大小，最小化存储区域到size相同的大小 public void trimToSize() { modCount++; if(size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } }</p> <p>//增加容量到指定大小（溢出会抛出OOM），通过这个方法可以打破MAX_ARRAY_SIZE限制 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; //首先尝试将新容量设置为原容量的（3/2） //这样做可以避免频繁小幅度的扩张带来的开销，我联想到一个类似的做法是滑动窗口中修改窗口大小的机制 int newCapacity = oldCapacity + (oldCapacity » 1); //如果尚未达到指定大小（这说明扩张幅度够大），设置为指定大小 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); }</p> <p>private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; }</p> <p>//当ArrayList不处于默认状态时，才可能扩展大小为小于DEFAULT_CAPACITY的容量； // 否则只有指定大小超过DEFAULT_CAPACITY时才进行扩展； //注意这个方法是public，区别于ensureCapacityInternal，这个方法是在外部使用的； public void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It’s already // supposed to be at default size. : DEFAULT_CAPACITY;</p> <div class="highlighter-rouge"><pre class="highlight"><code>if (minCapacity &gt; minExpand) {
    ensureExplicitCapacity(minCapacity);
} }
</code></pre></div> <p>//ArrayList内部扩展大小使用此方法，没有上个条件方法限制 //但如果处于默认状态，扩展大小仍然不能小于DEFAULT_CAPACITY private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); }</p> <div class="highlighter-rouge"><pre class="highlight"><code>ensureExplicitCapacity(minCapacity); }
</code></pre></div> <p>private void ensureExplicitCapacity(int minCapacity) { modCount++;</p> <div class="highlighter-rouge"><pre class="highlight"><code>// overflow-conscious code
if (minCapacity - elementData.length &gt; 0)
    grow(minCapacity); }
</code></pre></div> <p>//删除[fromIndex, toIndex)范围的元素 //操作后将末尾newSize之后的元素置空，防止内存泄漏 protected void removeRange(int fromIndex, int toIndex) { modCount++; //fail-fast int numMoved = size - toIndex; System.arraycopy(elementData, fromIndex, elementData, toIndex, numMoved);</p> <div class="highlighter-rouge"><pre class="highlight"><code>//清空多余的元素引用
int newSize = size - (toIndex - fromIndex);
for(int i = newSize; i &lt; size; i++)
    elementData[i] = null;
size = newSize; }
</code></pre></div> <p>//批量删除，complement为false时删除数组缓冲区中集合c包含的元素，true，删除集合c中不包含的元素，可以用实现交，差等集合运算 //使用复制的方法，而不是调用remove()的方式，减少了元素的重复复制 //同样要将newSize之外的元素引用置空，防止内存泄漏 private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0; //不变式，w &lt;= r boolean modified = false; try { for (; r &lt; size; r++) { if(c.contains(elementData[r]) == complement) { elementData[w++] = elementData[r]; } } } finally { //如果有异常抛出，保存好还未处理的数组元素 if (r != size) { System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; } if(w != size) { for(int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; } } return modified; }</p> <p>//由调用者检查index是否合法 private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[–size] = null; // clear to let GC do its work } 2.4 辅助方法 （1）检查索引是否合法； （2）返回指定位置的元素； private void rangeCheck(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); }</p> <p>private void rangeCheckForAdd(int index) { if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); }</p> <p>private String outOfBoundsMsg(int index) { return “Index: “+index+”, Size: “+size; }</p> <p>//复用 <a href="https://github.com/SuppressWarnings" class="user-mention">@SuppressWarnings</a>(“unchecked”) E elementData(int index) { return (E) elementData[index]; } 2.5 SubList与ArrayList的关系 该SubList是非静态内部类实现，基于同一个缓存数组，和Iterator一样维护一个modCount副本，防止并发修改； <a href="https://github.com/Override" class="user-mention">@Override</a> public List<e> subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); } 2.6 List实现要点 toArray使用保护性拷贝； 总来的来说这一块比较简单； //获取指定位置的元素对象引用 <a href="https://github.com/Override" class="user-mention">@Override</a> public E get(int index) { rangeCheck(index); return elementData(index); }</e></p> <p>//注意set方法不是结构性修改，因此并没有modCount++ <a href="https://github.com/Override" class="user-mention">@Override</a> public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; }</p> <p>//各种add方法实现 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean add(E e) { //检查并扩增大小，该方法会增加修改计数器，并且一次扩展(3/2)大小防止了频繁扩展带来的开销 ensureCapacityInternal(size + 1); elementData[size++] = e; return true; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public void add(int index, E element) { rangeCheckForAdd(index);</p> <div class="highlighter-rouge"><pre class="highlight"><code>ensureCapacityInternal(size + 1);
//将数组缓冲区中，index及之后的结点后移
System.arraycopy(elementData, index, elementData, index + 1,
        size - index);
elementData[index] = element;
size++; }
</code></pre></div> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean addAll(Collection&lt;? extends E&gt; c) { //获取集合中的元素数组，这样做的好处在于可以自由操作这些元素，而不用影响集合c Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); //增加modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return true; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index);</p> <div class="highlighter-rouge"><pre class="highlight"><code>Object[] a = c.toArray();
int numNew = a.length;
ensureCapacityInternal(size + numNew); //增加modCount

//如果是在尾部插入就不需要移动了
int numMoved = size - index;
if(numMoved &gt; 0)
    System.arraycopy(elementData, index, elementData, index + numNew,
            numMoved);

System.arraycopy(a, 0, elementData, index, numNew);
size += numNew;
return true; }
</code></pre></div> <p>//各种删除的实现 <a href="https://github.com/Override" class="user-mention">@Override</a> public E remove(int index) { rangeCheck(index);</p> <div class="highlighter-rouge"><pre class="highlight"><code>modCount++; //fail-fast
E oldValue = elementData(index);

int numMoved = size - index - 1;
if(numMoved &gt; 0)
    System.arraycopy(elementData, index + 1, elementData, index,
            numMoved);
elementData[--size] = null; //防止内存泄漏

return oldValue; }
</code></pre></div> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; }</p> <p>//保留差集 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean removeAll(Collection&lt;?&gt; c) { Objects.nonNull(c); return batchRemove(c, false); }</p> <p>//保留交集 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean retainAll(Collection&lt;?&gt; c) { Objects.nonNull(c); return batchRemove(c, true); }</p> <p>//置空防止内存泄漏 <a href="https://github.com/Override" class="user-mention">@Override</a> public void clear() { modCount++;</p> <div class="highlighter-rouge"><pre class="highlight"><code>for(int i = 0; i &lt; size; i++)
    elementData[i] = null;

size = 0; }
</code></pre></div> <p>//正向查找，返回元素第一次出现的索引值 <a href="https://github.com/Override" class="user-mention">@Override</a> public int indexOf(Object o) { if(o == null) { for (int i = 0; i &lt; size; i++) if (elementData[i] == null) return i; } else { for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; } return -1; }</p> <p>//反向查找，返回元素最后一次出现的索引值 <a href="https://github.com/Override" class="user-mention">@Override</a> public int lastIndexOf(Object o) { if(o == null) { for (int i = size - 1; i &gt;= 0; –i) if(elementData[i] == null) return i; } else { for (int i = size - 1; i &gt;= 0; –i) if (o.equals(elementData[i])) return i; } return -1; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean contains(Object o) { return indexOf(o) &gt;= 0; }</p> <p>//对数组进行排序 <a href="https://github.com/Override" class="user-mention">@Override</a> <a href="https://github.com/SuppressWarnings" class="user-mention">@SuppressWarnings</a>(“unchecked”) public void sort(Comparator&lt;? super E&gt; c) { final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; }</p> <p>//保护性拷贝 <a href="https://github.com/Override" class="user-mention">@Override</a> public Object[] toArray() { return Arrays.copyOf(elementData, size); }</p> <p><a href="https://github.com/SuppressWarnings" class="user-mention">@SuppressWarnings</a>(“unchecked”) <a href="https://github.com/Override" class="user-mention">@Override</a> public <t> T[] toArray(T[] a) { if(a.length &lt; size) //必须创建一个与参数类型相同的数组 return (T[])Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; //用来帮助调用者确定集合长度（只有在明确知道集合中没有null元素时才有用） return a; }</t></p> <p>Arraylist排序方面还没有看。</p> <p>LinkedList 参考学习资料： （1）JDK1.7之前的【Java集合源码剖析】LinkedList源码剖析</p> <ol> <li>LinkedList的要点 （1）双向链表：LinkedList基于双向链表实现的（Entry有next，previous指针），因此可以把它当栈，队列和双端队列使用； 在JDK1.7之前LinkedList之前是循环链表的方式实现两端插入的，包含一个无值的头结点，JDK1.7及以上是包含两个指针分别指向头结点和尾结点； （3）线程不安全：LinkedList通过维护modCount修改计数，每个迭代器保存各自的修改计数与modCount对比检验的方式防止并发修改； （4）性能特点：由于是链表实现，不支持快速随机存取，因此get(index)效率不高，在循环时一定注意不能误用；支持高效的结构性修改（只需要移动指针指向）；因此LinkedList定义了内部类实现ListIterator，避免使用效率低下的get()（AbstractList的迭代器是基于get()的），iterator()返回也是这个内部类实例； （5）克隆和序列化：实现了Serializable和Cloneable接口，支持序列化和克隆，其中序列化使用writeObject和readObject不采用默认的序列化机制，只保存size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销； （6）置空操作：强调一点，对应容器，删除结点时x = null;是很有必要的，让容器，容器中的结点在清除后不要互相引用的保存在堆中，影响垃圾回收，因为JVM一般是进行可达性分析的；</li> <li> <p>基本结构 2.1 结点类 双向链表，链表包含2个指针：头结点指针，尾结点指针； 结点（Node），包含2个指针，指向前驱结点和后序结点； transient int size = 0; <br> //不变式：(first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null) transient Node<e> first; //不变式：(first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null) transient Node<e> last; //结点 private static class Node<e> { E item; Node<e> next; Node<e> prev;</e></e></e></e></e></p> <p>Node(Node<e> prev, E element, Node<e> next) { this.item = element; this.next = next; this.prev = prev; } } 2.2 列表迭代器ListIterator非静态内部类实现 （1）每个迭代器对象独立维护一个expectedModCount进行修改计数检查，每次进行修改操作之前（包括set方法）检查计数，防止并发修改（抛出ConcurrentModificationException异常）； （2）lastReturned这个变量很关键，结构性修改一次之后（add和remove）这个变量被置空，因此对于迭代器调用一次add或remove之后调用next才可以在此remove和set； （3）ListIterator支持两个方向的迭代遍历； private class ListItr implements ListIterator<e> { //lastReturned保存最后返回的结点引用，当add，remove结构性修改后将这个值置空用于标识结构结构已修改 private Node<e> lastReturned; private Node<e> next; private int nextIndex; //每个迭代器保存创建时modCount，维护自己的modCount防止因为并发修改造成的不一致 private int expectedModCount = modCount;</e></e></e></e></e></p> <p>ListItr(int index) { next = (index == size) ? null : node(index); nextIndex = index; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public void add(E e) { //每次结构性修改之前必须先检查modCount是否同步，保证同时只有一个ListIterator可以修改链表 checkForComodification(); //lastReturned置空，防止删除之前的结点 lastReturned = null; if(next == null) linkLast(e); else linkBefore(e, next); nextIndex++; expectedModCount++; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean hasNext() { return nextIndex &lt; size; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E next() { //检查修改计数 checkForComodification(); if(!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean hasPrevious() { //nextIndex时显然不能有prev return nextIndex &gt; 0; }</p> <p>//前一个结点，此时next和lastReturned值一致 <a href="https://github.com/Override" class="user-mention">@Override</a> public E previous() { checkForComodification(); if(!hasPrevious()) throw new NoSuchElementException(); nextIndex–; lastReturned = next = (next == null) ? last : next.prev; return lastReturned.item; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public int nextIndex() { return nextIndex; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public int previousIndex() { return nextIndex - 1; }</p> <p>//删除最后返回的结点 <a href="https://github.com/Override" class="user-mention">@Override</a> public void remove() { //检查修改计数 checkForComodification(); if(lastReturned == null) throw new IllegalStateException();</p> <div class="highlighter-rouge"><pre class="highlight"><code> Node&lt;E&gt; lastNext = lastReturned.next;
 unlink(lastReturned);
 //如果next和lastReturned（这种情况在previous执行后出现），要修改next值
 if(next == lastReturned)
     next = lastNext; //虽然删除了一个结点，但是next向后移动了一位，因此nextIndex值不需要修改
 else
     nextIndex--;
 lastReturned = null;
 expectedModCount++;  }
</code></pre></div> <p>//修改最后返回结点的值 <a href="https://github.com/Override" class="user-mention">@Override</a> public void set(E e) { if(lastReturned == null) throw new IllegalStateException(); checkForComodification(); lastReturned.item = e; }</p> <p>//检查是否并发修改 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } }</p> </li> <li>操作 LinkedList继承自AbstractSequentialList，实现了List，Deque，Serializable和Cloneable；因此可以按此顺序进行解释，首先分析LinkedList自身最很核心的方法。 3.1 核心操作 包括linkFirst，linkLast，linkBefore，unlink，unlinkFirst，unlinkLast，node；这7个方法实现了双向链表最核心的功能，其他接口实现大部分是基于这7个方法的。 这些方法有几个重要的细节： （1）删除结点的时候置空操作； （2）modCount的修改； （3）node方法查找某个位置的结点根据index和size/2的关系进行优化处理； //在头端插入 private void linkFirst(E e) { final Node<e> f = first; final Node<e> newNode = new Node&lt;&gt;(e, null, f); first = newNode; if(f == null) { //原链表为空时last指针也要指向新结点 last = newNode; } else { f.prev = newNode; } ++size; //增加修改次数 ++modCount; } //在尾端插入 void linkLast(E e) { final Node<e> l = last; final Node<e> newNode = new Node&lt;&gt;(e, l, null); last = newNode; if(l == null) { //原链表为空时first指针也要执行新结点 first = newNode; } else { l.next = newNode; } ++size; ++modCount; } //在指定结点前插入 void linkBefore(E e, Node<e> succ) { final Node<e> pred = succ.prev; final Node<e> newNode = new Node&lt;&gt;(e, succ.prev, succ); succ.prev = newNode; if(pred == null) { first = newNode; } else { pred.next = newNode; } ++size; ++modCount; } //删除第一个结点，由调用者判断是否有头结点 private E unlinkFirst(Node<e> f) { final E element = f.item; final Node<e> next = f.next; f.next = null; //删除之后置为null，不影响被引用对象的垃圾回收 f.item = null; first = next; //first指针指向next if(next == null) last = null; else next.prev = null; --size; //数量减少 ++modCount; //修改计数增加 return element; } //删除最后一个结点 private E unlinkLast(Node<e> l) { final E element = l.item; final Node<e> prev = l.prev; l.item = null; //置空不影响原被引用对象的垃圾回收 l.prev = null; last = prev; if(prev == null) first = null; else prev.next = null; --size; ++modCount; return element; } //删除链表中某个结点 E unlink(Node<e> x) { final E element = x.item; final Node<e> prev = x.prev; final Node<e> next = x.next; x.item = null; //置空，不影响垃圾回收 if(prev == null) first = next; else { prev.next = next; x.prev = null; } if(next == null) last = prev; else { next.prev = prev; x.next = null; } --size; ++modCount; return element; }</e></e></e></e></e></e></e></e></e></e></e></e></e></e>
</li> </ol> <p>//获取指定位置的结点，通过index是否小于size/2进行优化 Node<e> node(int index) { //如果小于size / 2从头开始搜索，否则从尾开始搜索 if(index &lt; (size &gt;&gt; 1)) { Node<e> x = first; for(int i = 0; i &lt; index; ++i) x = x.next; return x; } else { Node<e> x = last; for(int i = size - 1; i &gt;= 0; --i) x = x.prev; return x; } } 3.2 私有辅助方法 包括检查查找索引，插入位置是否合法； //检查索引是否合法 private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } //检查索引是否合法，不合法抛出异常 private void checkElementIndex(int index) { if(isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private String outOfBoundsMsg(int index) { return "Index: "+index+", Size: "+size; } //检查待插入位置的索引值是否合法 private boolean isPositionIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt;= size; } //检查待插入位置的索引值是否合法，不合法抛出异常 private void checkPositionIndex(int index) { if(isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 3.3 List接口实现 （1）基于Node内部表示，因此List的关键方法也要依赖与内部表示； （2）注意，LinkedList的subList实现没有覆盖AbstractList的实现； //添加结点，在表尾 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean add(E e) { linkLast(e); return true; }</e></e></e></p> <p>//在指定位置添加结点 <a href="https://github.com/Override" class="user-mention">@Override</a> public void add(int index, E element) { //检查插入位置是否合法 checkPositionIndex(index);</p> <div class="highlighter-rouge"><pre class="highlight"><code>if(index == size) //排除为空的可能
    linkLast(element);
else { //index &lt; size时
    linkBefore(element, node(index));
} }
</code></pre></div> <p>//将一个集合中元素添加在指定位置之后，注意双向链表中指针值的设置 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean addAll(int index, Collection&lt;? extends E&gt; c) { //检验插入位置是否合法 checkPositionIndex(index);</p> <div class="highlighter-rouge"><pre class="highlight"><code>//将这个集合中的保存到新数组中，再进行操作，这是一种“安全”的做法
//使用toArray的目的是为了调用者可以自由的操作这个数组，而不会影响原来的集合
//返回的是对象数组，因为将集合类本身并不知道具体是什么类型，因此无法以最具体的类型声明数组
//调用此方法也意味着我们要进行强制类型转换，不过可以像addAll这样通过参数的类型参数来限制保证正确的类型
Object[] a = c.toArray();
int numNew = a.length; //arraylength指令（乱入一记字节码指令）
if(numNew == 0)
    return false;

//声明两个变量（指针）用来辅助设置插入过程中前后结点的指针值
//保存succ最后修改这个结点的prev指针（如果不为空的话）
Node&lt;E&gt; pred, succ;
//插入位置正好是末尾，无法通过node()查找定位到
//否则找到index位置的结点，并确定pred的值
if(index == size) {
    pred = last;
    succ = null;
} else {
    succ = node(index);
    pred = succ.prev;
}

for(Object o : a) {
    @SuppressWarnings("unchecked") E element = (E)o;
    Node&lt;E&gt; newNode = new Node&lt;&gt;(element, pred, succ);
    if(pred == null) //在表头插入，设置frist值
        first = newNode;
    else
        pred.next = newNode;
    pred = newNode;
}

//设置后续结点的prev
if(succ == null) //在末尾插入修改last的指向
    last = pred;
else {
    pred.next = succ;
    succ.prev = pred;
}

size += numNew;
++modCount;

return true; }
</code></pre></div> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean addAll(Collection&lt;? extends E&gt; c) { addAll(size, c); return true; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E get(int index) { //检验索引值是否合法，不合法抛出异常 checkElementIndex(index); return node(index).item; }</p> <p>//设置并返回旧值 <a href="https://github.com/Override" class="user-mention">@Override</a> public E set(int index, E element) { //检验索引值是否合法，不合法抛出异常 checkElementIndex(index); Node<e> x = node(index); E oldVal = x.item; x.item = element; return oldVal; }</e></p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E remove(int index) { checkElementIndex(index); return unlink(node(index)); }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean remove(Object o) { if(o == null) { for(Node<e> x = first; x != null; x = x.next) { if(x.item == null) { unlink(x); return true; } } } else { for(Node<e> x = first; x != null; x = x.next) { if(o.equals(x.item)) { unlink(x); return true; } } } return false; }</e></e></p> <p>//清空链表，尤其注意置空，让结点之间，结点和元素之间不在互相引用的存在堆中，让它们“独立”的接受垃圾回收 <a href="https://github.com/Override" class="user-mention">@Override</a> public void clear() { for(Node<e> x = first; x != null;) { Node<e> next = x.next; //置空，不要影响原来被引用对象的垃圾回收 x.item = null; x.next = null; x.prev = null; x = next; } first = last = null; size = 0; ++modCount; }</e></e></p> <p>//查找指定对象第一次出现的位置 <a href="https://github.com/Override" class="user-mention">@Override</a> public int indexOf(Object o) { int index = 0; if(o == null) { for(Node<e> x = first; x != null; x = x.next) { if(x.item == null) return index; index++; } } else { for(Node<e> x = first; x != null; x = x.next) { if(o.equals(x.item)) return index; index++; } } return -1; }</e></e></p> <p>//查找指定对象最后一次出现的位置 <a href="https://github.com/Override" class="user-mention">@Override</a> public int lastIndexOf(Object o) { int index = 0;</p> <div class="highlighter-rouge"><pre class="highlight"><code>if(o == null) {
    for(Node&lt;E&gt; x = last; x != null; x = x.prev) {
        if(x.item == null)
            return index;
        index++;
    }
} else {
    for(Node&lt;E&gt; x = last; x != null; x = x.prev) {
        if(o.equals(x.item))
            return index;
        index++;
    }
}

return -1; }
</code></pre></div> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public int size() { return size; }</p> <p>//注意contains，indexOf，lastIndexOf方法接受的都是Object <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean contains(Object o) { return indexOf(o) != -1; }</p> <p>//列表迭代器 <a href="https://github.com/Override" class="user-mention">@Override</a> public ListIterator<e> listIterator(int index) { checkPositionIndex(index); return new ListItr(index); }</e></p> <p>//保存为数组，这里只能返回Object，因为不能通过泛型参数创建对象/数组对象 //通过toArray方法可以自由操作该集合内元素而不影响该集合 <a href="https://github.com/Override" class="user-mention">@Override</a> public Object[] toArray() { Object[] result = new Object[size]; int i = 0; for(Node<e> x = first; x != null; x = x.next) { result[i++] = x.item; } return result; }</e></p> <p>//toArray的泛型方法版本，相对于toArray()来说可以进行必要的类型检查，但是创建数组的责任交给了调用者 <a href="https://github.com/SuppressWarnings" class="user-mention">@SuppressWarnings</a>(“unchecked”) <a href="https://github.com/Override" class="user-mention">@Override</a> public <t> T[] toArray(T[] a) { //检查长度是否能够存放所有元素 if(a.length &lt; size) //小于size重新通过反射创建 a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size);</t></p> <div class="highlighter-rouge"><pre class="highlight"><code>int i = 0;
//通过Object数组引用，可以避开泛型参数的限制，数组对象本身可以检查存入的类型是否正确，不正确保存ArrayStoreException
Object[] result = a;
for(Node&lt;E&gt; x = first; x != null; x = x.next) {
    result[i++] = x.item;
}

//如果数组长度大于集合长度，size位置置空
if(a.length &gt; size) {
    a[size] = null;
}

return a; } 3.4 Deque双端队列的实现 （1）与其他队列实现一样：offer（入队），poll（出队），peek（队首元素）不抛出异常，remove～（不同位置的删除方法），element（队首元素）为空是抛出异常； （2）实现pop和push，栈操作，以链表头作为栈顶； @Override public void addFirst(E e) {
linkFirst(e); }
</code></pre></div> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public void addLast(E e) { linkLast(e); }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean offerFirst(E e) { addFirst(e); return true; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public boolean offerLast(E e) { addLast(e); return true; }</p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E removeFirst() { final Node<e> f = first; if(f == null) throw new NoSuchElementException("first is not exist."); return unlinkFirst(f); }</e></p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E removeLast() { final Node<e> l = last; if(l == null) throw new NoSuchElementException("last is not exist."); return unlinkLast(l); }</e></p> <p>//poll~方法不抛出异常，为空时返回null <a href="https://github.com/Override" class="user-mention">@Override</a> public E pollFirst() { final Node<e> f = first; return f == null ? null : unlinkFirst(f); }</e></p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E pollLast() { final Node<e> l = last; return l == null ? null : unlinkLast(l); }</e></p> <p>//get~方法抛出异常 <a href="https://github.com/Override" class="user-mention">@Override</a> public E getFirst() { final Node<e> f = first; if(f == null) throw new NoSuchElementException(); return f.item; }</e></p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E getLast() { final Node<e> l = last; if(l == null) throw new NoSuchElementException(); return l.item; }</e></p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E peekFirst() { final Node<e> f = first; return f == null ? null : f.item; }</e></p> <p><a href="https://github.com/Override" class="user-mention">@Override</a> public E peekLast() { final Node<e> l = last; return l == null ? null : l.item; }</e></p> <p>//删除队列中第一个该对象的引用 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean removeFirstOccurrence(Object o) { return remove(o); }</p> <p>//删除队列中最后一个该对象的引用 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean removeLastOccurrence(Object o) { if(o == null) { for(Node<e> x = last; x != null; x = x.prev) { if(x.item == null) { unlink(x); return true; } } } else { for(Node<e> x = last; x != null; x = x.prev) { if(o.equals(x.item)) { unlink(x); return true; } } } return false; }</e></e></p> <p>//入队操作，链表尾部插入，不抛出异常 <a href="https://github.com/Override" class="user-mention">@Override</a> public boolean offer(E e) { return add(e); }</p> <p>//出队操作，不抛出异常 <a href="https://github.com/Override" class="user-mention">@Override</a> public E poll() { final Node<e> f = first; return f == null ? null : unlinkFirst(f); }</e></p> <p>//获取表头元素，栈的操作，不抛出异常 <a href="https://github.com/Override" class="user-mention">@Override</a> public E peek() { final Node<e> f = first; return (f == null) ? null : f.item; }</e></p> <p>//出队删除，检查抛出异常 <a href="https://github.com/Override" class="user-mention">@Override</a> public E remove() { return removeFirst(); }</p> <p>//获取表头元素，抛出异常 <a href="https://github.com/Override" class="user-mention">@Override</a> public E element() { return getFirst(); }</p> <p>//入栈，表头添加，栈的操作 <a href="https://github.com/Override" class="user-mention">@Override</a> public void push(E e) { addFirst(e); }</p> <p>//出栈，表头删除，栈的操作 <a href="https://github.com/Override" class="user-mention">@Override</a> public E pop() { return removeFirst(); } 3.5 AbstractSequentialList的实现 实现逆序迭代器。 //逆序迭代器 <a href="https://github.com/Override" class="user-mention">@Override</a> public Iterator<e> descendingIterator() { return new DescendingIterator(); }</e></p> <p>private class DescendingIterator implements Iterator<e> { private final ListItr itr = new ListItr(size()); public boolean hasNext() { return itr.hasPrevious(); } public E next() { return itr.previous(); } public void remove() { itr.remove(); } } 3.6 Cloneable的实现 <a href="https://github.com/Override" class="user-mention">@Override</a> public Object clone() { MLinkedList<e> clone = superClone(); clone.first = clone.last = null; clone.size = 0; clone.modCount = 0;</e></e></p> <div class="highlighter-rouge"><pre class="highlight"><code>for(Node&lt;E&gt; x = first; x != null; x = x.next) {
    clone.add(x.item);
}

return clone; }
</code></pre></div> <p><a href="https://github.com/SuppressWarnings" class="user-mention">@SuppressWarnings</a>(“unchecked”) private MLinkedList<e> superClone() { try { return (MLinkedList<e>) super.clone(); } catch (CloneNotSupportedException e) { throw new InternalError(e); } } 3.7 序列化支持 （1）LinkedList的size，first，last使用transient关键字，使用自定义的序列化机制，只写入size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销； （2）在JDK1.7之前使用的并不是Node而是Entry，也是保存了元素对象而不是Entry，这样的考虑解决了LinkedList的兼容问题； //序列化版本号，是数据域和方法签名的数字指纹（SHA） private static final long serialVersionUID = 876323262645176354L;</e></e></p> <p>//代替默认的序列化过程，这里值写入了元素对象和元素集合大小 //在JDK1.7之前使用的并不是Node而是Entry，也是保存了元素对象而不是Entry，这样的考虑解决了LinkedList的兼容问题 //这也是为什么用transient修饰size，first，last域的原因 //一方面是隐藏内部表示信息，一方面节省了开销 private void writeObject(java.io.ObjectOutputStream s) throws IOException { //写入包括魔数，序列化格式版本号，包括所有对象的类型和（非静态和非transient）数据域 //每个对象包括一个序列号 //相同对象重复出现将被视为对这个对象序列号的引用 s.defaultWriteObject();</p> <div class="highlighter-rouge"><pre class="highlight"><code>s.writeInt(size);

for(Node&lt;E&gt; x = first; x != null; x = x.next) {
    s.writeObject(x.item);
} }
</code></pre></div> <p>//反序列化过程，同样读取size和元素对象，重新“构建”链表 <a href="https://github.com/SuppressWarnings" class="user-mention">@SuppressWarnings</a>(“unchecked”) private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject();</p> <div class="highlighter-rouge"><pre class="highlight"><code>int size = s.readInt();

for(int i = 0; i &lt; size; i++) {
    linkLast((E)s.readObject());
} } 4. LinkedList对Java 8新特性的支持 4.1 对Lambda表达式的支持
</code></pre></div> <p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。</p> <p>LinkedList的本质是双向链表。 (01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。 (02) LinkedList包含两个重要的成员：header 和 size。 　　header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。 　　size是双向链表中节点的个数。 (01) LinkedList 实际上是通过双向链表去实现的。 它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。 (02) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。 (03) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。 (04) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 (05) 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。 总结起来如下表格： 第一个元素（头部）最后一个元素（尾部） 抛出异常 特殊值 抛出异常 特殊值 插入addFirst(e) offerFirst(e) addLast(e) offerLast(e) 移除removeFirst() pollFirst() removeLast() pollLast() 检查getFirst() peekFirst() getLast() peekLast() (06) LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价：</p> <p>队列方法等效方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst()</p> <p>(07) LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价： 栈方法 等效方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst()</p> <p>Stack Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。 java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在“Java 集合系列06之 Vector详细介绍(源码解析)和使用示例”中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。 (01) Stack实际上也是通过数组去实现的。 执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。 执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。 执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。 (02) Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。</p> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="http://127.0.0.1:4000//tags/#test" title="Pages tagged test" class="tag"><span class="term">test</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=http://127.0.0.1:4000//test/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Like</span> </a> <a href="https://twitter.com/intent/tweet?text=http://127.0.0.1:4000//test/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=http://127.0.0.1:4000//test/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread --> </header> <!-- JS --> <script src="http://127.0.0.1:4000//assets/js/jquery-1.12.0.min.js"></script> <script src="http://127.0.0.1:4000//assets/js/jquery.dlmenu.min.js"></script> <script src="http://127.0.0.1:4000//assets/js/jquery.goup.min.js"></script> <script src="http://127.0.0.1:4000//assets/js/jquery.magnific-popup.min.js"></script> <script src="http://127.0.0.1:4000//assets/js/jquery.fitvid.min.js"></script> <script src="http://127.0.0.1:4000//assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'taylantatli'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
