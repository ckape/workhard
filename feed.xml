<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="http://127.0.0.1:4000//feed.xml" rel="self" type="application/atom+xml" /><link href="http://127.0.0.1:4000//" rel="alternate" type="text/html" /><updated>2016-09-21T00:26:32+08:00</updated><id>http://127.0.0.1:4000//</id><title type="html">WorkHard-Website</title><subtitle>This is my own site.</subtitle><entry><title type="html">Test</title><link href="http://127.0.0.1:4000//test/" rel="alternate" type="text/html" title="Test" /><published>2016-09-20T00:00:00+08:00</published><updated>2016-09-20T00:00:00+08:00</updated><id>http://127.0.0.1:4000//test</id><content type="html" xml:base="http://127.0.0.1:4000//test/">&lt;h2 id=&quot;list&quot;&gt;List&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ArrayList（常用）
      Implemented Interfaces:Serializable,Cloneable,Iterable&lt;E&gt;,Collection&lt;E&gt;,List&lt;E&gt;,RandomAccess&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/li&gt;
  &lt;li&gt;LinkedList（常用）
      Implemented Interfaces:Serializable,Cloneable,Iterable&lt;E&gt;,Collection&lt;E&gt;,Deque&lt;E&gt;,List&lt;E&gt;,Queue&lt;E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/li&gt;
  &lt;li&gt;Stack（了解）&lt;/li&gt;
  &lt;li&gt;CopyOnWriteArrayList&lt;/li&gt;
  &lt;li&gt;AbstractList&lt;/li&gt;
  &lt;li&gt;AbstractSequentialList&lt;/li&gt;
  &lt;li&gt;AttributeList&lt;/li&gt;
  &lt;li&gt;RoleList&lt;/li&gt;
  &lt;li&gt;RoleUnresolvedList&lt;/li&gt;
  &lt;li&gt;Vector&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arraylistarraylist&quot;&gt;ArrayList（ArrayList中的操作不是线程安全的）&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;modCount&lt;/code&gt;: The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.（已从结构上修改此列表的次数。从结构上修改是指更改列表的大小，或者打乱列表，从而使正在进行的迭代产生错误的结果。）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ArrayList要点
（1）基于数组实现：内部表示通过控制对象数组的访问，数组是不能动态修改大小的，因此根据元素数量/指定容量大小，通过创建新数组，复制元素对象是ArrayList的核心原理之一；
（2）性能特点：因为基于数组的，因此可以实现快速随机访问，比LinkedList效率高；但是增加/删除等需要通过复制数组元素（部分或全部）来实现，效率比LinkedList低；
（3）线程不安全：同样使用modCount修改计数，类似乐观锁的fail-fast来防止并发修改带来的不一致，ArrayList的每个Iterator，ListIterator，SubList实例都独立维护一个基于ArrayList实例modCount的expectedModCount；
（4）优化手段：
单例模式应用：EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA这两个单例的空数组对象，分别被“空状态”和“默认状态”的ArrayList共享；
grow方法的增长机制：每次扩展数组的大小至少扩展到原数据的3/2大小，减少了创建新数组和复制动作的次数；
（5）克隆和序列化：实现了Serializable和Cloneable接口，支持序列化和克隆，其中序列化使用writeObject和readObject不采用默认的序列化机制，只保存size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销；
（6）防止内存泄漏的置空动作：维护一个数组也是自己维护内存管理，因为数组也持有这引用，删除时要及时置空不能影响GC活动，虽然LinkedList已经说了，再强调下；&lt;/li&gt;
  &lt;li&gt;基本结构和操作
2.1 重要属性
//默认初始化容量
private static final int DEFAULT_CAPACITY = 10;
/*
 所有Empty数组列表共享一个空数组对象，不仅可以减少重复对象的创建（单例模式应用），还可以标识空列表状态
 单例模式（区别于享元模式）：
 一是这里只有一个对象；
 二是不仅仅是节省内存，更重要的是起到共享并标识“空数组列表”的作用；
 EMPTY_ELEMENTDATA标识“空”状态，DEFAULTCAPACITY_EMPTY_ELEMENTDATA标识默认状态
 &lt;em&gt;/
private static final Object[] EMPTY_ELEMENTDATA = {};
/&lt;/em&gt;
 默认状态创建数组列表实例使用该数组，使用一个单例空数组并且不直接使用EMPTY_ELEMENTDATA而是新键一个空数组的原因是：
 一是用于标识不同的状态，区别于“空数组列表”，DEFAULTCAPACITY_EMPTY_ELEMENTDATA表示数组列表还未插入元素；
 二是等到实际有元素再分配合适大小的数组内存空间，起到延迟加载的作用；
 三是同样单例可以让所有默认状态列表使用一个空数组对象，节省内存；
&lt;em&gt;/
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
/&lt;/em&gt;
使用transient的目的是为了隐藏内部表示
使用Object的原因：
（1）Object可以引用所有具体类型的数组对象；
（2）实际的ArrayList的类型参数对于ArrayList对象本身是不可知的，泛型的本质是擦除，并借助变量，方法，类的签名来进行类型检查和转换;
 因此可以用Object数组存放元素对象，依赖方法和类型参数让编译器和JVM进行类型检查和转换（比如插入checkcast指令等等）；
 */
transient Object[] elementData;
//元素个数
private int size;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;/*
翻译：
一些实现可能会保存一些首部信息在数组对象中。
试图分配一个比MAX_ARRAY_SIZE大的数组可能会造成OOM（Requested array size exceeds VM limit）。
也就是说一些JVM的实现可能会限制数组大小小于Integer.MAX_VALUE，因此检查是必要的。
 &lt;em&gt;/
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
2.2 不同版本的构造器
这里可以看到在创建ArrayList对象实例的时候：
（1）ArrayList()：默认状态，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA，这也是一个空数组，延迟加载，第一次插入时才分配内存；
（2）如果指定的初始化容量为0,拷贝构造器传入集合为空，使用EMPTY_ELEMENTDATA；
/&lt;/em&gt;
不同版本的构造器
 */
//如果指定初始化容量为“0”，使用EMPTY_ELEMENTDATA
public ArrayList(int initialCapacity) {
    if (initialCapacity &amp;gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(“Illegal Capacity: “+
                initialCapacity);
    }
}
//创建默认初始化容量列表，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}&lt;/p&gt;

&lt;p&gt;//拷贝构造器，注意使用toArray获取要插入元素对象
public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
    elementData = c.toArray();
    if((size = elementData.length) != 0) {
        /*
        注意，toArray返回的Object[]引用，而Object[]可以作为超类引用子类对象比如A[]（假设A是E的子类）
        如果toArray返回是A[]数组对象，那么如果类型B对象（B extends E）可能会引起后续的插入时的ArrayStoreException，读取元素时的ClassCheckException
        因此如果返回的不是Object[]对象，要创建一个Object[]并复制元素引用
         */
        if(elementData.getClass() != Object[].class) {
            elementData = Arrays.copyOf(elementData, size, Objects[].class);
        }
    } else {
        //一个空数组列表，直接使用EMPTY_ELEMENTDATA
        elementData = EMPTY_ELEMENTDATA;
    }
}
2.3 核心操作
主要方法包括：trimToSize（压缩缓存数组），grow（扩展容量），ensure～（不同情况下调用的扩容方法），removeRange（范围删除），batchRemove（批量删除），fastRemove（基于复制的快速复制），这些方法供之后方法调用；
//压缩缓存区大小，最小化存储区域到size相同的大小
public void trimToSize() {
    modCount++;
    if(size &amp;lt; elementData.length) {
        elementData = (size == 0)
                ? EMPTY_ELEMENTDATA
                : Arrays.copyOf(elementData, size);
    }
}&lt;/p&gt;

&lt;p&gt;//增加容量到指定大小（溢出会抛出OOM），通过这个方法可以打破MAX_ARRAY_SIZE限制
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    //首先尝试将新容量设置为原容量的（3/2）
    //这样做可以避免频繁小幅度的扩张带来的开销，我联想到一个类似的做法是滑动窗口中修改窗口大小的机制
    int newCapacity = oldCapacity + (oldCapacity » 1);
    //如果尚未达到指定大小（这说明扩张幅度够大），设置为指定大小
    if (newCapacity - minCapacity &amp;lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}&lt;/p&gt;

&lt;p&gt;private static int hugeCapacity(int minCapacity) {
    if (minCapacity &amp;lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &amp;gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
}&lt;/p&gt;

&lt;p&gt;//当ArrayList不处于默认状态时，才可能扩展大小为小于DEFAULT_CAPACITY的容量；
// 否则只有指定大小超过DEFAULT_CAPACITY时才进行扩展；
//注意这个方法是public，区别于ensureCapacityInternal，这个方法是在外部使用的；
public void ensureCapacity(int minCapacity) {
    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It’s already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (minCapacity &amp;gt; minExpand) {
    ensureExplicitCapacity(minCapacity);
} }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//ArrayList内部扩展大小使用此方法，没有上个条件方法限制
//但如果处于默认状态，扩展大小仍然不能小于DEFAULT_CAPACITY
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ensureExplicitCapacity(minCapacity); }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;private void ensureExplicitCapacity(int minCapacity) {
    modCount++;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// overflow-conscious code
if (minCapacity - elementData.length &amp;gt; 0)
    grow(minCapacity); }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//删除[fromIndex, toIndex)范围的元素
//操作后将末尾newSize之后的元素置空，防止内存泄漏
protected void removeRange(int fromIndex, int toIndex) {
    modCount++; //fail-fast
    int numMoved = size - toIndex;
    System.arraycopy(elementData, fromIndex, elementData, toIndex,
            numMoved);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//清空多余的元素引用
int newSize = size - (toIndex - fromIndex);
for(int i = newSize; i &amp;lt; size; i++)
    elementData[i] = null;
size = newSize; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//批量删除，complement为false时删除数组缓冲区中集合c包含的元素，true，删除集合c中不包含的元素，可以用实现交，差等集合运算
//使用复制的方法，而不是调用remove()的方式，减少了元素的重复复制
//同样要将newSize之外的元素引用置空，防止内存泄漏
private boolean batchRemove(Collection&amp;lt;?&amp;gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
    int r = 0, w = 0; //不变式，w &amp;lt;= r
    boolean modified = false;
    try {
        for (; r &amp;lt; size; r++) {
            if(c.contains(elementData[r]) == complement) {
                elementData[w++] = elementData[r];
            }
        }
    } finally {
        //如果有异常抛出，保存好还未处理的数组元素
        if (r != size) {
            System.arraycopy(elementData, r,
                    elementData, w,
                    size - r);
            w += size - r;
        }
        if(w != size) {
            for(int i = w; i &amp;lt; size; i++)
                elementData[i] = null;
            modCount += size - w;
            size = w;
            modified = true;
        }
    }
    return modified;
}&lt;/p&gt;

&lt;p&gt;//由调用者检查index是否合法
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &amp;gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                numMoved);
    elementData[–size] = null; // clear to let GC do its work
}
2.4 辅助方法
（1）检查索引是否合法；
（2）返回指定位置的元素；
private void rangeCheck(int index) {
    if (index &amp;gt;= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}&lt;/p&gt;

&lt;p&gt;private void rangeCheckForAdd(int index) {
    if (index &amp;gt; size || index &amp;lt; 0)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}&lt;/p&gt;

&lt;p&gt;private String outOfBoundsMsg(int index) {
    return “Index: “+index+”, Size: “+size;
}&lt;/p&gt;

&lt;p&gt;//复用
@SuppressWarnings(“unchecked”)
E elementData(int index) {
    return (E) elementData[index];
}
2.5 SubList与ArrayList的关系
该SubList是非静态内部类实现，基于同一个缓存数组，和Iterator一样维护一个modCount副本，防止并发修改；
@Override
public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    subListRangeCheck(fromIndex, toIndex, size);
    return new SubList(this, 0, fromIndex, toIndex);
}
2.6 List实现要点
toArray使用保护性拷贝；
总来的来说这一块比较简单；
//获取指定位置的元素对象引用
@Override
public E get(int index) {
    rangeCheck(index);
    return elementData(index);
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//注意set方法不是结构性修改，因此并没有modCount++
@Override
public E set(int index, E element) {
    rangeCheck(index);
    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}&lt;/p&gt;

&lt;p&gt;//各种add方法实现
@Override
public boolean add(E e) {
    //检查并扩增大小，该方法会增加修改计数器，并且一次扩展(3/2)大小防止了频繁扩展带来的开销
    ensureCapacityInternal(size + 1);
    elementData[size++] = e;
    return true;
}&lt;/p&gt;

&lt;p&gt;@Override
public void add(int index, E element) {
    rangeCheckForAdd(index);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ensureCapacityInternal(size + 1);
//将数组缓冲区中，index及之后的结点后移
System.arraycopy(elementData, index, elementData, index + 1,
        size - index);
elementData[index] = element;
size++; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;@Override
public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
    //获取集合中的元素数组，这样做的好处在于可以自由操作这些元素，而不用影响集合c
    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew); //增加modCount
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    return true;
}&lt;/p&gt;

&lt;p&gt;@Override
public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
    rangeCheckForAdd(index);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object[] a = c.toArray();
int numNew = a.length;
ensureCapacityInternal(size + numNew); //增加modCount

//如果是在尾部插入就不需要移动了
int numMoved = size - index;
if(numMoved &amp;gt; 0)
    System.arraycopy(elementData, index, elementData, index + numNew,
            numMoved);

System.arraycopy(a, 0, elementData, index, numNew);
size += numNew;
return true; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//各种删除的实现
@Override
public E remove(int index) {
    rangeCheck(index);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;modCount++; //fail-fast
E oldValue = elementData(index);

int numMoved = size - index - 1;
if(numMoved &amp;gt; 0)
    System.arraycopy(elementData, index + 1, elementData, index,
            numMoved);
elementData[--size] = null; //防止内存泄漏

return oldValue; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;@Override
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &amp;lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &amp;lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}&lt;/p&gt;

&lt;p&gt;//保留差集
@Override
public boolean removeAll(Collection&amp;lt;?&amp;gt; c) {
    Objects.nonNull(c);
    return batchRemove(c, false);
}&lt;/p&gt;

&lt;p&gt;//保留交集
@Override
public boolean retainAll(Collection&amp;lt;?&amp;gt; c) {
    Objects.nonNull(c);
    return batchRemove(c, true);
}&lt;/p&gt;

&lt;p&gt;//置空防止内存泄漏
@Override
public void clear() {
    modCount++;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(int i = 0; i &amp;lt; size; i++)
    elementData[i] = null;

size = 0; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//正向查找，返回元素第一次出现的索引值
@Override
public int indexOf(Object o) {
    if(o == null) {
        for (int i = 0; i &amp;lt; size; i++)
            if (elementData[i] == null)
                return i;
    } else {
        for (int i = 0; i &amp;lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}&lt;/p&gt;

&lt;p&gt;//反向查找，返回元素最后一次出现的索引值
@Override
public int lastIndexOf(Object o) {
    if(o == null) {
        for (int i = size - 1; i &amp;gt;= 0; –i)
            if(elementData[i] == null)
                return i;
    } else {
        for (int i = size - 1; i &amp;gt;= 0; –i)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}&lt;/p&gt;

&lt;p&gt;@Override
public boolean contains(Object o) {
    return indexOf(o) &amp;gt;= 0;
}&lt;/p&gt;

&lt;p&gt;//对数组进行排序
@Override
@SuppressWarnings(“unchecked”)
public void sort(Comparator&amp;lt;? super E&amp;gt; c) {
    final int expectedModCount = modCount;
    Arrays.sort((E[]) elementData, 0, size, c);
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}&lt;/p&gt;

&lt;p&gt;//保护性拷贝
@Override
public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}&lt;/p&gt;

&lt;p&gt;@SuppressWarnings(“unchecked”)
@Override
public &lt;T&gt; T[] toArray(T[] a) {
    if(a.length &amp;lt; size)
        //必须创建一个与参数类型相同的数组
        return (T[])Arrays.copyOf(elementData, size, a.getClass());
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &amp;gt; size)
        a[size] = null; //用来帮助调用者确定集合长度（只有在明确知道集合中没有null元素时才有用）
    return a;
}&lt;/T&gt;&lt;/p&gt;

&lt;p&gt;Arraylist排序方面还没有看。&lt;/p&gt;

&lt;p&gt;LinkedList
参考学习资料：
（1）JDK1.7之前的【Java集合源码剖析】LinkedList源码剖析&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;LinkedList的要点
（1）双向链表：LinkedList基于双向链表实现的（Entry有next，previous指针），因此可以把它当栈，队列和双端队列使用；
在JDK1.7之前LinkedList之前是循环链表的方式实现两端插入的，包含一个无值的头结点，JDK1.7及以上是包含两个指针分别指向头结点和尾结点；
（3）线程不安全：LinkedList通过维护modCount修改计数，每个迭代器保存各自的修改计数与modCount对比检验的方式防止并发修改；
（4）性能特点：由于是链表实现，不支持快速随机存取，因此get(index)效率不高，在循环时一定注意不能误用；支持高效的结构性修改（只需要移动指针指向）；因此LinkedList定义了内部类实现ListIterator，避免使用效率低下的get()（AbstractList的迭代器是基于get()的），iterator()返回也是这个内部类实例；
（5）克隆和序列化：实现了Serializable和Cloneable接口，支持序列化和克隆，其中序列化使用writeObject和readObject不采用默认的序列化机制，只保存size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销；
（6）置空操作：强调一点，对应容器，删除结点时x = null;是很有必要的，让容器，容器中的结点在清除后不要互相引用的保存在堆中，影响垃圾回收，因为JVM一般是进行可达性分析的；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基本结构
2.1 结点类
双向链表，链表包含2个指针：头结点指针，尾结点指针；
结点（Node），包含2个指针，指向前驱结点和后序结点；
transient int size = 0;  &lt;br /&gt;
//不变式：(first == null &amp;amp;&amp;amp; last == null) || (first.prev == null &amp;amp;&amp;amp; first.item != null)
transient Node&lt;E&gt; first;
//不变式：(first == null &amp;amp;&amp;amp; last == null) || (last.next == null &amp;amp;&amp;amp; last.item != null)
transient Node&lt;E&gt; last;
//结点
private static class Node&lt;E&gt; {
 E item;
 Node&lt;E&gt; next;
 Node&lt;E&gt; prev;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

    &lt;p&gt;Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
     this.item = element;
     this.next = next;
     this.prev = prev;
 }
}
2.2 列表迭代器ListIterator非静态内部类实现
（1）每个迭代器对象独立维护一个expectedModCount进行修改计数检查，每次进行修改操作之前（包括set方法）检查计数，防止并发修改（抛出ConcurrentModificationException异常）；
（2）lastReturned这个变量很关键，结构性修改一次之后（add和remove）这个变量被置空，因此对于迭代器调用一次add或remove之后调用next才可以在此remove和set；
（3）ListIterator支持两个方向的迭代遍历；
private class ListItr implements ListIterator&lt;E&gt; {
 //lastReturned保存最后返回的结点引用，当add，remove结构性修改后将这个值置空用于标识结构结构已修改
 private Node&lt;E&gt; lastReturned;
 private Node&lt;E&gt; next;
 private int nextIndex;
 //每个迭代器保存创建时modCount，维护自己的modCount防止因为并发修改造成的不一致
 private int expectedModCount = modCount;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

    &lt;p&gt;ListItr(int index) {
     next = (index == size) ? null : node(index);
     nextIndex = index;
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public void add(E e) {
     //每次结构性修改之前必须先检查modCount是否同步，保证同时只有一个ListIterator可以修改链表
     checkForComodification();
     //lastReturned置空，防止删除之前的结点
     lastReturned = null;
     if(next == null)
         linkLast(e);
     else
         linkBefore(e, next);
     nextIndex++;
     expectedModCount++;
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public boolean hasNext() {
     return nextIndex &amp;lt; size;
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public E next() {
     //检查修改计数
     checkForComodification();
     if(!hasNext())
         throw new NoSuchElementException();
     lastReturned = next;
     next = next.next;
     nextIndex++;
     return lastReturned.item;
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public boolean hasPrevious() {
     //nextIndex时显然不能有prev
     return nextIndex &amp;gt; 0;
 }&lt;/p&gt;

    &lt;p&gt;//前一个结点，此时next和lastReturned值一致
 @Override
 public E previous() {
     checkForComodification();
     if(!hasPrevious())
         throw new NoSuchElementException();
     nextIndex–;
     lastReturned = next = (next == null) ? last : next.prev;
     return lastReturned.item;
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public int nextIndex() {
     return nextIndex;
 }&lt;/p&gt;

    &lt;p&gt;@Override
 public int previousIndex() {
     return nextIndex - 1;
 }&lt;/p&gt;

    &lt;p&gt;//删除最后返回的结点
 @Override
 public void remove() {
     //检查修改计数
     checkForComodification();
     if(lastReturned == null)
         throw new IllegalStateException();&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Node&amp;lt;E&amp;gt; lastNext = lastReturned.next;
 unlink(lastReturned);
 //如果next和lastReturned（这种情况在previous执行后出现），要修改next值
 if(next == lastReturned)
     next = lastNext; //虽然删除了一个结点，但是next向后移动了一位，因此nextIndex值不需要修改
 else
     nextIndex--;
 lastReturned = null;
 expectedModCount++;  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;//修改最后返回结点的值
 @Override
 public void set(E e) {
     if(lastReturned == null)
         throw new IllegalStateException();
     checkForComodification();
     lastReturned.item = e;
 }&lt;/p&gt;

    &lt;p&gt;//检查是否并发修改
 final void checkForComodification() {
     if (modCount != expectedModCount)
         throw new ConcurrentModificationException();
 }
}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;操作
LinkedList继承自AbstractSequentialList，实现了List，Deque，Serializable和Cloneable；因此可以按此顺序进行解释，首先分析LinkedList自身最很核心的方法。
3.1 核心操作
包括linkFirst，linkLast，linkBefore，unlink，unlinkFirst，unlinkLast，node；这7个方法实现了双向链表最核心的功能，其他接口实现大部分是基于这7个方法的。
这些方法有几个重要的细节：
（1）删除结点的时候置空操作；
（2）modCount的修改；
（3）node方法查找某个位置的结点根据index和size/2的关系进行优化处理；
//在头端插入
private void linkFirst(E e) {
 final Node&lt;E&gt; f = first;
 final Node&lt;E&gt; newNode = new Node&amp;lt;&amp;gt;(e, null, f);
 first = newNode;
 if(f == null) {
     //原链表为空时last指针也要指向新结点
     last = newNode;
 } else {
     f.prev = newNode;
 }
 ++size;
 //增加修改次数
 ++modCount;
}
//在尾端插入
void linkLast(E e) {
 final Node&lt;E&gt; l = last;
 final Node&lt;E&gt; newNode = new Node&amp;lt;&amp;gt;(e, l, null);
 last = newNode;
 if(l == null) {
     //原链表为空时first指针也要执行新结点
     first = newNode;
 } else {
     l.next = newNode;
 }
 ++size;
 ++modCount;
}
//在指定结点前插入
void linkBefore(E e, Node&lt;E&gt; succ) {
 final Node&lt;E&gt; pred = succ.prev;
 final Node&lt;E&gt; newNode = new Node&amp;lt;&amp;gt;(e, succ.prev, succ);
 succ.prev = newNode;
 if(pred == null) {
     first = newNode;
 } else {
     pred.next = newNode;
 }
 ++size;
 ++modCount;
}
//删除第一个结点，由调用者判断是否有头结点
private E unlinkFirst(Node&lt;E&gt; f) {
 final E element = f.item;
 final Node&lt;E&gt; next = f.next;
 f.next = null; //删除之后置为null，不影响被引用对象的垃圾回收
 f.item = null;
 first = next; //first指针指向next
 if(next == null)
     last = null;
 else
     next.prev = null;
 --size; //数量减少
 ++modCount; //修改计数增加
 return element;
}
//删除最后一个结点
private E unlinkLast(Node&lt;E&gt; l) {
 final E element = l.item;
 final Node&lt;E&gt; prev = l.prev;
 l.item = null; //置空不影响原被引用对象的垃圾回收
 l.prev = null;
 last = prev;
 if(prev == null)
     first = null;
 else
     prev.next = null;
 --size;
 ++modCount;
 return element;
}
//删除链表中某个结点
E unlink(Node&lt;E&gt; x) {
 final E element = x.item;
 final Node&lt;E&gt; prev = x.prev;
 final Node&lt;E&gt; next = x.next;
 x.item = null; //置空，不影响垃圾回收
 if(prev == null)
     first = next;
 else {
     prev.next = next;
     x.prev = null;
 }
 if(next == null)
     last = prev;
 else {
     next.prev = prev;
     x.next = null;
 }
 --size;
 ++modCount;
 return element;
}&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;//获取指定位置的结点，通过index是否小于size/2进行优化
Node&lt;E&gt; node(int index) {
    //如果小于size / 2从头开始搜索，否则从尾开始搜索
    if(index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
        Node&lt;E&gt; x = first;
        for(int i = 0; i &amp;lt; index; ++i)
            x = x.next;
        return x;
    } else {
        Node&lt;E&gt; x = last;
        for(int i = size - 1; i &amp;gt;= 0; --i)
            x = x.prev;
        return x;
    }
}
3.2 私有辅助方法
包括检查查找索引，插入位置是否合法；
//检查索引是否合法
private boolean isElementIndex(int index) {
    return index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt; size;
}
//检查索引是否合法，不合法抛出异常
private void checkElementIndex(int index) {
    if(isElementIndex(index))
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}
private String outOfBoundsMsg(int index) {
    return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
}
//检查待插入位置的索引值是否合法
private boolean isPositionIndex(int index) {
    return index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;= size;
}
//检查待插入位置的索引值是否合法，不合法抛出异常
private void checkPositionIndex(int index) {
    if(isPositionIndex(index))
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}
3.3 List接口实现
（1）基于Node内部表示，因此List的关键方法也要依赖与内部表示；
（2）注意，LinkedList的subList实现没有覆盖AbstractList的实现；
//添加结点，在表尾
@Override
public boolean add(E e) {
    linkLast(e);
    return true;
}&lt;/E&gt;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//在指定位置添加结点
@Override
public void add(int index, E element) {
    //检查插入位置是否合法
    checkPositionIndex(index);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(index == size) //排除为空的可能
    linkLast(element);
else { //index &amp;lt; size时
    linkBefore(element, node(index));
} }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//将一个集合中元素添加在指定位置之后，注意双向链表中指针值的设置
@Override
public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
    //检验插入位置是否合法
    checkPositionIndex(index);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//将这个集合中的保存到新数组中，再进行操作，这是一种“安全”的做法
//使用toArray的目的是为了调用者可以自由的操作这个数组，而不会影响原来的集合
//返回的是对象数组，因为将集合类本身并不知道具体是什么类型，因此无法以最具体的类型声明数组
//调用此方法也意味着我们要进行强制类型转换，不过可以像addAll这样通过参数的类型参数来限制保证正确的类型
Object[] a = c.toArray();
int numNew = a.length; //arraylength指令（乱入一记字节码指令）
if(numNew == 0)
    return false;

//声明两个变量（指针）用来辅助设置插入过程中前后结点的指针值
//保存succ最后修改这个结点的prev指针（如果不为空的话）
Node&amp;lt;E&amp;gt; pred, succ;
//插入位置正好是末尾，无法通过node()查找定位到
//否则找到index位置的结点，并确定pred的值
if(index == size) {
    pred = last;
    succ = null;
} else {
    succ = node(index);
    pred = succ.prev;
}

for(Object o : a) {
    @SuppressWarnings(&quot;unchecked&quot;) E element = (E)o;
    Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(element, pred, succ);
    if(pred == null) //在表头插入，设置frist值
        first = newNode;
    else
        pred.next = newNode;
    pred = newNode;
}

//设置后续结点的prev
if(succ == null) //在末尾插入修改last的指向
    last = pred;
else {
    pred.next = succ;
    succ.prev = pred;
}

size += numNew;
++modCount;

return true; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;@Override
public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
    addAll(size, c);
    return true;
}&lt;/p&gt;

&lt;p&gt;@Override
public E get(int index) {
    //检验索引值是否合法，不合法抛出异常
    checkElementIndex(index);
    return node(index).item;
}&lt;/p&gt;

&lt;p&gt;//设置并返回旧值
@Override
public E set(int index, E element) {
    //检验索引值是否合法，不合法抛出异常
    checkElementIndex(index);
    Node&lt;E&gt; x = node(index);
    E oldVal = x.item;
    x.item = element;
    return oldVal;
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;@Override
public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}&lt;/p&gt;

&lt;p&gt;@Override
public boolean remove(Object o) {
    if(o == null) {
        for(Node&lt;E&gt; x = first; x != null; x = x.next) {
            if(x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for(Node&lt;E&gt; x = first; x != null; x = x.next) {
            if(o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//清空链表，尤其注意置空，让结点之间，结点和元素之间不在互相引用的存在堆中，让它们“独立”的接受垃圾回收
@Override
public void clear() {
    for(Node&lt;E&gt; x = first; x != null;) {
        Node&lt;E&gt; next = x.next;
        //置空，不要影响原来被引用对象的垃圾回收
        x.item = null;
        x.next = null;
        x.prev = null;
        x = next;
    }
    first = last = null;
    size = 0;
    ++modCount;
}&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//查找指定对象第一次出现的位置
@Override
public int indexOf(Object o) {
    int index = 0;
    if(o == null) {
        for(Node&lt;E&gt; x = first; x != null; x = x.next) {
            if(x.item == null)
                return index;
            index++;
        }
    } else {
        for(Node&lt;E&gt; x = first; x != null; x = x.next) {
            if(o.equals(x.item))
                return index;
            index++;
        }
    }
    return -1;
}&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//查找指定对象最后一次出现的位置
@Override
public int lastIndexOf(Object o) {
    int index = 0;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(o == null) {
    for(Node&amp;lt;E&amp;gt; x = last; x != null; x = x.prev) {
        if(x.item == null)
            return index;
        index++;
    }
} else {
    for(Node&amp;lt;E&amp;gt; x = last; x != null; x = x.prev) {
        if(o.equals(x.item))
            return index;
        index++;
    }
}

return -1; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;@Override
public int size() {
    return size;
}&lt;/p&gt;

&lt;p&gt;//注意contains，indexOf，lastIndexOf方法接受的都是Object
@Override
public boolean contains(Object o) {
    return indexOf(o) != -1;
}&lt;/p&gt;

&lt;p&gt;//列表迭代器
@Override
public ListIterator&lt;E&gt; listIterator(int index) {
    checkPositionIndex(index);
    return new ListItr(index);
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//保存为数组，这里只能返回Object，因为不能通过泛型参数创建对象/数组对象
//通过toArray方法可以自由操作该集合内元素而不影响该集合
@Override
public Object[] toArray() {
    Object[] result = new Object[size];
    int i = 0;
    for(Node&lt;E&gt; x = first; x != null; x = x.next) {
        result[i++] = x.item;
    }
    return result;
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//toArray的泛型方法版本，相对于toArray()来说可以进行必要的类型检查，但是创建数组的责任交给了调用者
@SuppressWarnings(“unchecked”)
@Override
public &lt;T&gt; T[] toArray(T[] a) {
    //检查长度是否能够存放所有元素
    if(a.length &amp;lt; size) //小于size重新通过反射创建
        a = (T[])java.lang.reflect.Array.newInstance(
                a.getClass().getComponentType(), size);&lt;/T&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int i = 0;
//通过Object数组引用，可以避开泛型参数的限制，数组对象本身可以检查存入的类型是否正确，不正确保存ArrayStoreException
Object[] result = a;
for(Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
    result[i++] = x.item;
}

//如果数组长度大于集合长度，size位置置空
if(a.length &amp;gt; size) {
    a[size] = null;
}

return a; } 3.4 Deque双端队列的实现 （1）与其他队列实现一样：offer（入队），poll（出队），peek（队首元素）不抛出异常，remove～（不同位置的删除方法），element（队首元素）为空是抛出异常； （2）实现pop和push，栈操作，以链表头作为栈顶； @Override public void addFirst(E e) {
linkFirst(e); }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;@Override
public void addLast(E e) {
    linkLast(e);
}&lt;/p&gt;

&lt;p&gt;@Override
public boolean offerFirst(E e) {
    addFirst(e);
    return true;
}&lt;/p&gt;

&lt;p&gt;@Override
public boolean offerLast(E e) {
    addLast(e);
    return true;
}&lt;/p&gt;

&lt;p&gt;@Override
public E removeFirst() {
    final Node&lt;E&gt; f = first;
    if(f == null)
        throw new NoSuchElementException(&quot;first is not exist.&quot;);
    return unlinkFirst(f);
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;@Override
public E removeLast() {
    final Node&lt;E&gt; l = last;
    if(l == null)
        throw new NoSuchElementException(&quot;last is not exist.&quot;);
    return unlinkLast(l);
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//poll~方法不抛出异常，为空时返回null
@Override
public E pollFirst() {
    final Node&lt;E&gt; f = first;
    return f == null ? null : unlinkFirst(f);
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;@Override
public E pollLast() {
    final Node&lt;E&gt; l = last;
    return l == null ? null : unlinkLast(l);
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//get~方法抛出异常
@Override
public E getFirst() {
    final Node&lt;E&gt; f = first;
    if(f == null)
        throw new NoSuchElementException();
    return f.item;
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;@Override
public E getLast() {
    final Node&lt;E&gt; l = last;
    if(l == null)
        throw new NoSuchElementException();
    return l.item;
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;@Override
public E peekFirst() {
    final Node&lt;E&gt; f = first;
    return f == null ? null : f.item;
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;@Override
public E peekLast() {
    final Node&lt;E&gt; l = last;
    return l == null ? null : l.item;
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//删除队列中第一个该对象的引用
@Override
public boolean removeFirstOccurrence(Object o) {
    return remove(o);
}&lt;/p&gt;

&lt;p&gt;//删除队列中最后一个该对象的引用
@Override
public boolean removeLastOccurrence(Object o) {
    if(o == null) {
        for(Node&lt;E&gt; x = last; x != null; x = x.prev) {
            if(x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for(Node&lt;E&gt; x = last; x != null; x = x.prev) {
            if(o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//入队操作，链表尾部插入，不抛出异常
@Override
public boolean offer(E e) {
    return add(e);
}&lt;/p&gt;

&lt;p&gt;//出队操作，不抛出异常
@Override
public E poll() {
    final Node&lt;E&gt; f = first;
    return f == null ? null : unlinkFirst(f);
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//获取表头元素，栈的操作，不抛出异常
@Override
public E peek() {
    final Node&lt;E&gt; f = first;
    return (f == null) ? null : f.item;
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//出队删除，检查抛出异常
@Override
public E remove() {
    return removeFirst();
}&lt;/p&gt;

&lt;p&gt;//获取表头元素，抛出异常
@Override
public E element() {
    return getFirst();
}&lt;/p&gt;

&lt;p&gt;//入栈，表头添加，栈的操作
@Override
public void push(E e) {
    addFirst(e);
}&lt;/p&gt;

&lt;p&gt;//出栈，表头删除，栈的操作
@Override
public E pop() {
    return removeFirst();
}
3.5 AbstractSequentialList的实现
实现逆序迭代器。
//逆序迭代器
@Override
public Iterator&lt;E&gt; descendingIterator() {
    return new DescendingIterator();
}&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;private class DescendingIterator implements Iterator&lt;E&gt; {
    private final ListItr itr = new ListItr(size());
    public boolean hasNext() {
        return itr.hasPrevious();
    }
    public E next() {
        return itr.previous();
    }
    public void remove() {
        itr.remove();
    }
}
3.6 Cloneable的实现
@Override
public Object clone() {
    MLinkedList&lt;E&gt; clone = superClone();
    clone.first = clone.last = null;
    clone.size = 0;
    clone.modCount = 0;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
    clone.add(x.item);
}

return clone; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;@SuppressWarnings(“unchecked”)
private MLinkedList&lt;E&gt; superClone() {
    try {
        return (MLinkedList&lt;E&gt;) super.clone();
    } catch (CloneNotSupportedException e) {
        throw new InternalError(e);
    }
}
3.7 序列化支持
（1）LinkedList的size，first，last使用transient关键字，使用自定义的序列化机制，只写入size和元素对象，一方面是隐藏内部表示信息，一方面节省了开销；
（2）在JDK1.7之前使用的并不是Node而是Entry，也是保存了元素对象而不是Entry，这样的考虑解决了LinkedList的兼容问题；
//序列化版本号，是数据域和方法签名的数字指纹（SHA）
private static final long serialVersionUID = 876323262645176354L;&lt;/E&gt;&lt;/E&gt;&lt;/p&gt;

&lt;p&gt;//代替默认的序列化过程，这里值写入了元素对象和元素集合大小
//在JDK1.7之前使用的并不是Node而是Entry，也是保存了元素对象而不是Entry，这样的考虑解决了LinkedList的兼容问题
//这也是为什么用transient修饰size，first，last域的原因
//一方面是隐藏内部表示信息，一方面节省了开销
private void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
    //写入包括魔数，序列化格式版本号，包括所有对象的类型和（非静态和非transient）数据域
    //每个对象包括一个序列号
    //相同对象重复出现将被视为对这个对象序列号的引用
    s.defaultWriteObject();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.writeInt(size);

for(Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
    s.writeObject(x.item);
} }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;//反序列化过程，同样读取size和元素对象，重新“构建”链表
@SuppressWarnings(“unchecked”)
private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException {
    s.defaultReadObject();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int size = s.readInt();

for(int i = 0; i &amp;lt; size; i++) {
    linkLast((E)s.readObject());
} } 4. LinkedList对Java 8新特性的支持 4.1 对Lambda表达式的支持
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。
LinkedList 实现 List 接口，能对它进行队列操作。
LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。
LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。
LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。
LinkedList 是非同步的。&lt;/p&gt;

&lt;p&gt;LinkedList的本质是双向链表。
(01) LinkedList继承于AbstractSequentialList，并且实现了Dequeue接口。
(02) LinkedList包含两个重要的成员：header 和 size。
　　header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。
　　size是双向链表中节点的个数。
(01) LinkedList 实际上是通过双向链表去实现的。
        它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。
(02) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。
(03) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。
(04) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。
(05) 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。
总结起来如下表格：
        第一个元素（头部）最后一个元素（尾部）
        抛出异常        特殊值            抛出异常        特殊值
插入addFirst(e)    offerFirst(e)    addLast(e)        offerLast(e)
移除removeFirst()  pollFirst()      removeLast()    pollLast()
检查getFirst()     peekFirst()      getLast()        peekLast()
(06) LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价：&lt;/p&gt;

&lt;p&gt;队列方法等效方法
add(e)        addLast(e)
offer(e)      offerLast(e)
remove()      removeFirst()
poll()        pollFirst()
element()     getFirst()
peek()        peekFirst()&lt;/p&gt;

&lt;p&gt;(07) LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价：
栈方法 等效方法
push(e)      addFirst(e)
pop()        removeFirst()
peek()       peekFirst()&lt;/p&gt;

&lt;p&gt;Stack
Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。
java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在“Java 集合系列06之 Vector详细介绍(源码解析)和使用示例”中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。
(01) Stack实际上也是通过数组去实现的。
       执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。
       执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。
       执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。
(02) Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。&lt;/p&gt;</content><category term="test" /><summary type="html">The first pages.</summary></entry><entry><title type="html">A Post with a Video</title><link href="http://127.0.0.1:4000//video-post/" rel="alternate" type="text/html" title="A Post with a Video" /><published>2016-03-15T00:00:00+08:00</published><updated>2016-03-15T00:00:00+08:00</updated><id>http://127.0.0.1:4000//video-post</id><content type="html" xml:base="http://127.0.0.1:4000//video-post/">&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/SU3kYxJmWuQ&quot; frameborder=&quot;0&quot;&gt; &lt;/iframe&gt;

&lt;p&gt;Video embeds are responsive and scale with the width of the main content block with the help of &lt;a href=&quot;http://fitvidsjs.com/&quot;&gt;FitVids&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Not sure if this only effects Kramdown or if it’s an issue with Markdown in general. But adding YouTube video embeds causes errors when building your Jekyll site. To fix add a space between the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; tags and remove &lt;code class=&quot;highlighter-rouge&quot;&gt;allowfullscreen&lt;/code&gt;. Example below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;iframe&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;560&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;315&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;//www.youtube.com/embed/SU3kYxJmWuQ&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;frameborder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/iframe&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><category term="sample" /><category term="post" /><category term="video" /><summary type="html">Custom written post descriptions are the way to go... if you're not lazy.</summary></entry><entry><title type="html">A Post with Images</title><link href="http://127.0.0.1:4000//sample-post-images/" rel="alternate" type="text/html" title="A Post with Images" /><published>2013-05-22T00:00:00+08:00</published><updated>2013-05-22T00:00:00+08:00</updated><id>http://127.0.0.1:4000//sample-post-images</id><content type="html" xml:base="http://127.0.0.1:4000//sample-post-images/">&lt;p&gt;Here are some examples of what a post with images might look like. If you want to display two or three images next to each other responsively use &lt;code class=&quot;highlighter-rouge&quot;&gt;figure&lt;/code&gt; with the appropriate &lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;. Each instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;figure&lt;/code&gt; is auto-numbered and displayed in the caption.&lt;/p&gt;

&lt;h3 id=&quot;figures-for-images-or-video&quot;&gt;Figures (for images or video)&lt;/h3&gt;

&lt;h4 id=&quot;one-up&quot;&gt;One Up&lt;/h4&gt;

&lt;figure&gt;
	&lt;a href=&quot;http://farm9.staticflickr.com/8426/7758832526_cc8f681e48_b.jpg&quot;&gt;&lt;img src=&quot;http://farm9.staticflickr.com/8426/7758832526_cc8f681e48_c.jpg&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;&lt;a href=&quot;http://www.flickr.com/photos/80901381@N04/7758832526/&quot; title=&quot;Morning Fog Emerging From Trees by A Guy Taking Pictures, on Flickr&quot;&gt;Morning Fog Emerging From Trees by A Guy Taking Pictures, on Flickr&lt;/a&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies.&lt;/p&gt;

&lt;h4 id=&quot;two-up&quot;&gt;Two Up&lt;/h4&gt;

&lt;p&gt;Apply the &lt;code class=&quot;highlighter-rouge&quot;&gt;half&lt;/code&gt; class like so to display two images side by side that share the same caption.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;figure&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;half&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/image-filename-1-large.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/image-filename-1.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/image-filename-2-large.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/image-filename-2.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;figcaption&amp;gt;&lt;/span&gt;Caption describing these two images.&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figcaption&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figure&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And you’ll get something that looks like this:&lt;/p&gt;

&lt;figure class=&quot;half&quot;&gt;
	&lt;a href=&quot;http://placehold.it/1200x600.JPG&quot;&gt;&lt;img src=&quot;http://placehold.it/600x300.jpg&quot; /&gt;&lt;/a&gt;
	&lt;a href=&quot;http://placehold.it/1200x600.jpeg&quot;&gt;&lt;img src=&quot;http://placehold.it/600x300.jpg&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;Two images.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;three-up&quot;&gt;Three Up&lt;/h4&gt;

&lt;p&gt;Apply the &lt;code class=&quot;highlighter-rouge&quot;&gt;third&lt;/code&gt; class like so to display three images side by side that share the same caption.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;figure&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;third&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/image-filename-1.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/image-filename-2.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/images/image-filename-3.jpg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;figcaption&amp;gt;&lt;/span&gt;Caption describing these three images.&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figcaption&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/figure&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And you’ll get something that looks like this:&lt;/p&gt;

&lt;figure class=&quot;third&quot;&gt;
	&lt;img src=&quot;http://placehold.it/600x300.jpg&quot; /&gt;
	&lt;img src=&quot;http://placehold.it/600x300.jpg&quot; /&gt;
	&lt;img src=&quot;http://placehold.it/600x300.jpg&quot; /&gt;
	&lt;figcaption&gt;Three images.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;alternative-way&quot;&gt;Alternative way&lt;/h3&gt;

&lt;p&gt;Another way to achieve the same result is to include &lt;code class=&quot;highlighter-rouge&quot;&gt;gallery&lt;/code&gt; Liquid template. In this case you
don’t have to write any HTML tags – just copy a small block of code, adjust the parameters (see below)
and fill the block with any number of links to images. You can mix relative and external links.&lt;/p&gt;

&lt;p&gt;Here is the block you might want to use:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-liquid&quot; data-lang=&quot;liquid&quot;&gt;&lt;span class=&quot;p&quot;&gt;{%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;capture&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%}&lt;/span&gt;
	http://vignette2.wikia.nocookie.net/naruto/images/9/97/Hinata.png
	http://vignette4.wikia.nocookie.net/naruto/images/7/79/Hinata_Part_II.png
	http://vignette1.wikia.nocookie.net/naruto/images/1/15/J%C5%ABho_S%C5%8Dshiken.png
&lt;span class=&quot;p&quot;&gt;{%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;endcapture&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;gallery&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;images&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;caption&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Test images&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Parameters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;caption&lt;/code&gt;: Sets the caption under the gallery (see &lt;code class=&quot;highlighter-rouge&quot;&gt;figcaption&lt;/code&gt; HTML tag above);&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cols&lt;/code&gt;: Sets the number of columns of the gallery.
Available values: [1..3].&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It will look something like this:&lt;/p&gt;

&lt;figure class=&quot;third&quot;&gt;
    
    &lt;a href=&quot;http://vignette2.wikia.nocookie.net/naruto/images/9/97/Hinata.png&quot;&gt;&lt;img src=&quot;http://vignette2.wikia.nocookie.net/naruto/images/9/97/Hinata.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;
    
    &lt;a href=&quot;http://vignette4.wikia.nocookie.net/naruto/images/7/79/Hinata_Part_II.png&quot;&gt;&lt;img src=&quot;http://vignette4.wikia.nocookie.net/naruto/images/7/79/Hinata_Part_II.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;
    
    &lt;a href=&quot;http://vignette1.wikia.nocookie.net/naruto/images/1/15/J%C5%ABho_S%C5%8Dshiken.png&quot;&gt;&lt;img src=&quot;http://vignette1.wikia.nocookie.net/naruto/images/1/15/J%C5%ABho_S%C5%8Dshiken.png&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;
    
    &lt;figcaption&gt;Test images&lt;/figcaption&gt;
&lt;/figure&gt;</content><category term="sample post" /><category term="images" /><category term="test" /><summary type="html">Examples and code for displaying images in posts.</summary></entry><entry><title type="html">Post with Image Feature</title><link href="http://127.0.0.1:4000//readability-feature-post/" rel="alternate" type="text/html" title="Post with Image Feature" /><published>2012-05-23T00:00:00+08:00</published><updated>2012-05-23T00:00:00+08:00</updated><id>http://127.0.0.1:4000//readability-feature-post</id><content type="html" xml:base="http://127.0.0.1:4000//readability-feature-post/">&lt;p&gt;Portland in shoreditch Vice, labore typewriter pariatur hoodie fap sartorial Austin. Pinterest literally occupy Schlitz forage. Odio ad blue bottle vinyl, 90’s narwhal commodo bitters pour-over nostrud. Ugh est hashtag in, fingerstache adipisicing laboris esse Pinterest shabby chic Portland. Shoreditch bicycle rights anim, flexitarian laboris put a bird on it vinyl cupidatat narwhal. Hashtag artisan skateboard, flannel Bushwick nesciunt salvia aute fixie do plaid post-ironic dolor McSweeney’s. Cliche pour-over chambray nulla four loko skateboard sapiente hashtag.&lt;/p&gt;

&lt;p&gt;Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies.&lt;/p&gt;

&lt;h2 id=&quot;cupidatat-90s-lo-fi-authentic-try-hard&quot;&gt;Cupidatat 90’s lo-fi authentic try-hard&lt;/h2&gt;

&lt;p&gt;In pug Portland incididunt mlkshk put a bird on it vinyl quinoa. Terry Richardson shabby chic +1, scenester Tonx excepteur tempor fugiat voluptate fingerstache aliquip nisi next level. Farm-to-table hashtag Truffaut, Odd Future ex meggings gentrify single-origin coffee try-hard 90’s.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sartorial hoodie&lt;/li&gt;
  &lt;li&gt;Labore viral forage&lt;/li&gt;
  &lt;li&gt;Tote bag selvage&lt;/li&gt;
  &lt;li&gt;DIY exercitation et id ugh tumblr church-key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Incididunt umami sriracha, ethical fugiat VHS ex assumenda yr irure direct trade. Marfa Truffaut bicycle rights, kitsch placeat Etsy kogi asymmetrical. Beard locavore flexitarian, kitsch photo booth hoodie plaid ethical readymade leggings yr.&lt;/p&gt;

&lt;p&gt;Aesthetic odio dolore, meggings disrupt qui readymade stumptown brunch Terry Richardson pour-over gluten-free. Banksy american apparel in selfies, biodiesel flexitarian organic meh wolf quinoa gentrify banjo kogi. Readymade tofu ex, scenester dolor umami fingerstache occaecat fashion axe Carles jean shorts minim. Keffiyeh fashion axe nisi Godard mlkshk dolore. Lomo you probably haven’t heard of them eu non, Odd Future Truffaut pug keytar meggings McSweeney’s Pinterest cred. Etsy literally aute esse, eu bicycle rights qui meggings fanny pack. Gentrify leggings pug flannel duis.&lt;/p&gt;

&lt;h2 id=&quot;forage-occaecat-cardigan-qui&quot;&gt;Forage occaecat cardigan qui&lt;/h2&gt;

&lt;p&gt;Fashion axe hella gastropub lo-fi kogi 90’s aliquip +1 veniam delectus tousled. Cred sriracha locavore gastropub kale chips, iPhone mollit sartorial. Anim dolore 8-bit, pork belly dolor photo booth aute flannel small batch. Dolor disrupt ennui, tattooed whatever salvia Banksy sartorial roof party selfies raw denim sint meh pour-over. Ennui eu cardigan sint, gentrify iPhone cornhole.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Whatever velit occaecat quis deserunt gastropub, leggings elit tousled roof party 3 wolf moon kogi pug blue bottle ea. Fashion axe shabby chic Austin quinoa pickled laborum bitters next level, disrupt deep v accusamus non fingerstache.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tote bag asymmetrical elit sunt. Occaecat authentic Marfa, hella McSweeney’s next level irure veniam master cleanse. Sed hoodie letterpress artisan wolf leggings, 3 wolf moon commodo ullamco. Anim occupy ea labore Terry Richardson. Tofu ex master cleanse in whatever pitchfork banh mi, occupy fugiat fanny pack Austin authentic. Magna fugiat 3 wolf moon, labore McSweeney’s sustainable vero consectetur. Gluten-free disrupt enim, aesthetic fugiat jean shorts trust fund keffiyeh magna try-hard.&lt;/p&gt;

&lt;h2 id=&quot;hoodie-duis&quot;&gt;Hoodie Duis&lt;/h2&gt;

&lt;p&gt;Actually salvia consectetur, hoodie duis lomo YOLO sunt sriracha. Aute pop-up brunch farm-to-table odio, salvia irure occaecat. Sriracha small batch literally skateboard. Echo Park nihil hoodie, aliquip forage artisan laboris. Trust fund reprehenderit nulla locavore. Stumptown raw denim kitsch, keffiyeh nulla twee dreamcatcher fanny pack ullamco 90’s pop-up est culpa farm-to-table. Selfies 8-bit do pug odio.&lt;/p&gt;

&lt;h3 id=&quot;thundercats-ho&quot;&gt;Thundercats Ho!&lt;/h3&gt;

&lt;p&gt;Fingerstache thundercats Williamsburg, deep v scenester Banksy ennui vinyl selfies mollit biodiesel duis odio pop-up. Banksy 3 wolf moon try-hard, sapiente enim stumptown deep v ad letterpress. Squid beard brunch, exercitation raw denim yr sint direct trade. Raw denim narwhal id, flannel DIY McSweeney’s seitan. Letterpress artisan bespoke accusamus, meggings laboris consequat Truffaut qui in seitan. Sustainable cornhole Schlitz, twee Cosby sweater banh mi deep v forage letterpress flannel whatever keffiyeh. Sartorial cred irure, semiotics ethical sed blue bottle nihil letterpress.&lt;/p&gt;

&lt;p&gt;Occupy et selvage squid, pug brunch blog nesciunt hashtag mumblecore skateboard yr kogi. Ugh small batch swag four loko. Fap post-ironic qui tote bag farm-to-table american apparel scenester keffiyeh vero, swag non pour-over gentrify authentic pitchfork. Schlitz scenester lo-fi voluptate, tote bag irony bicycle rights pariatur vero Vice freegan wayfarers exercitation nisi shoreditch. Chambray tofu vero sed. Street art swag literally leggings, Cosby sweater mixtape PBR lomo Banksy non in pitchfork ennui McSweeney’s selfies. Odd Future Banksy non authentic.&lt;/p&gt;

&lt;p&gt;Aliquip enim artisan dolor post-ironic. Pug tote bag Marfa, deserunt pour-over Portland wolf eu odio intelligentsia american apparel ugh ea. Sunt viral et, 3 wolf moon gastropub pug id. Id fashion axe est typewriter, mlkshk Portland art party aute brunch. Sint pork belly Cosby sweater, deep v mumblecore kitsch american apparel. Try-hard direct trade tumblr sint skateboard. Adipisicing bitters excepteur biodiesel, pickled gastropub aute veniam.&lt;/p&gt;</content><category term="sample post" /><category term="readability" /><category term="test" /><category term="image" /><category term="feature" /><summary type="html">A ton of text to test readability with image feature.</summary></entry><entry><title type="html">Testing Readability with a Bunch of Text</title><link href="http://127.0.0.1:4000//readability-post/" rel="alternate" type="text/html" title="Testing Readability with a Bunch of Text" /><published>2012-05-22T00:00:00+08:00</published><updated>2012-05-22T00:00:00+08:00</updated><id>http://127.0.0.1:4000//readability-post</id><content type="html" xml:base="http://127.0.0.1:4000//readability-post/">&lt;p&gt;Portland in shoreditch Vice, labore typewriter pariatur hoodie fap sartorial Austin. Pinterest literally occupy Schlitz forage. Odio ad blue bottle vinyl, 90’s narwhal commodo bitters pour-over nostrud. Ugh est hashtag in, fingerstache adipisicing laboris esse Pinterest shabby chic Portland. Shoreditch bicycle rights anim, flexitarian laboris put a bird on it vinyl cupidatat narwhal. Hashtag artisan skateboard, flannel Bushwick nesciunt salvia aute fixie do plaid post-ironic dolor McSweeney’s. Cliche pour-over chambray nulla four loko skateboard sapiente hashtag.&lt;/p&gt;

&lt;p&gt;Vero laborum commodo occupy. Semiotics voluptate mumblecore pug. Cosby sweater ullamco quinoa ennui assumenda, sapiente occupy delectus lo-fi. Ea fashion axe Marfa cillum aliquip. Retro Bushwick keytar cliche. Before they sold out sustainable gastropub Marfa readymade, ethical Williamsburg skateboard brunch qui consectetur gentrify semiotics. Mustache cillum irony, fingerstache magna pour-over keffiyeh tousled selfies.&lt;/p&gt;

&lt;h2 id=&quot;cupidatat-90s-lo-fi-authentic-try-hard&quot;&gt;Cupidatat 90’s lo-fi authentic try-hard&lt;/h2&gt;

&lt;p&gt;In pug Portland incididunt mlkshk put a bird on it vinyl quinoa. Terry Richardson shabby chic +1, scenester Tonx excepteur tempor fugiat voluptate fingerstache aliquip nisi next level. Farm-to-table hashtag Truffaut, Odd Future ex meggings gentrify single-origin coffee try-hard 90’s.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sartorial hoodie&lt;/li&gt;
  &lt;li&gt;Labore viral forage&lt;/li&gt;
  &lt;li&gt;Tote bag selvage&lt;/li&gt;
  &lt;li&gt;DIY exercitation et id ugh tumblr church-key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Incididunt umami sriracha, ethical fugiat VHS ex assumenda yr irure direct trade. Marfa Truffaut bicycle rights, kitsch placeat Etsy kogi asymmetrical. Beard locavore flexitarian, kitsch photo booth hoodie plaid ethical readymade leggings yr.&lt;/p&gt;

&lt;p&gt;Aesthetic odio dolore, meggings disrupt qui readymade stumptown brunch Terry Richardson pour-over gluten-free. Banksy american apparel in selfies, biodiesel flexitarian organic meh wolf quinoa gentrify banjo kogi. Readymade tofu ex, scenester dolor umami fingerstache occaecat fashion axe Carles jean shorts minim. Keffiyeh fashion axe nisi Godard mlkshk dolore. Lomo you probably haven’t heard of them eu non, Odd Future Truffaut pug keytar meggings McSweeney’s Pinterest cred. Etsy literally aute esse, eu bicycle rights qui meggings fanny pack. Gentrify leggings pug flannel duis.&lt;/p&gt;

&lt;h2 id=&quot;forage-occaecat-cardigan-qui&quot;&gt;Forage occaecat cardigan qui&lt;/h2&gt;

&lt;p&gt;Fashion axe hella gastropub lo-fi kogi 90’s aliquip +1 veniam delectus tousled. Cred sriracha locavore gastropub kale chips, iPhone mollit sartorial. Anim dolore 8-bit, pork belly dolor photo booth aute flannel small batch. Dolor disrupt ennui, tattooed whatever salvia Banksy sartorial roof party selfies raw denim sint meh pour-over. Ennui eu cardigan sint, gentrify iPhone cornhole.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Whatever velit occaecat quis deserunt gastropub, leggings elit tousled roof party 3 wolf moon kogi pug blue bottle ea. Fashion axe shabby chic Austin quinoa pickled laborum bitters next level, disrupt deep v accusamus non fingerstache.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tote bag asymmetrical elit sunt. Occaecat authentic Marfa, hella McSweeney’s next level irure veniam master cleanse. Sed hoodie letterpress artisan wolf leggings, 3 wolf moon commodo ullamco. Anim occupy ea labore Terry Richardson. Tofu ex master cleanse in whatever pitchfork banh mi, occupy fugiat fanny pack Austin authentic. Magna fugiat 3 wolf moon, labore McSweeney’s sustainable vero consectetur. Gluten-free disrupt enim, aesthetic fugiat jean shorts trust fund keffiyeh magna try-hard.&lt;/p&gt;

&lt;h2 id=&quot;hoodie-duis&quot;&gt;Hoodie Duis&lt;/h2&gt;

&lt;p&gt;Actually salvia consectetur, hoodie duis lomo YOLO sunt sriracha. Aute pop-up brunch farm-to-table odio, salvia irure occaecat. Sriracha small batch literally skateboard. Echo Park nihil hoodie, aliquip forage artisan laboris. Trust fund reprehenderit nulla locavore. Stumptown raw denim kitsch, keffiyeh nulla twee dreamcatcher fanny pack ullamco 90’s pop-up est culpa farm-to-table. Selfies 8-bit do pug odio.&lt;/p&gt;

&lt;h3 id=&quot;thundercats-ho&quot;&gt;Thundercats Ho!&lt;/h3&gt;

&lt;p&gt;Fingerstache thundercats Williamsburg, deep v scenester Banksy ennui vinyl selfies mollit biodiesel duis odio pop-up. Banksy 3 wolf moon try-hard, sapiente enim stumptown deep v ad letterpress. Squid beard brunch, exercitation raw denim yr sint direct trade. Raw denim narwhal id, flannel DIY McSweeney’s seitan. Letterpress artisan bespoke accusamus, meggings laboris consequat Truffaut qui in seitan. Sustainable cornhole Schlitz, twee Cosby sweater banh mi deep v forage letterpress flannel whatever keffiyeh. Sartorial cred irure, semiotics ethical sed blue bottle nihil letterpress.&lt;/p&gt;

&lt;p&gt;Occupy et selvage squid, pug brunch blog nesciunt hashtag mumblecore skateboard yr kogi. Ugh small batch swag four loko. Fap post-ironic qui tote bag farm-to-table american apparel scenester keffiyeh vero, swag non pour-over gentrify authentic pitchfork. Schlitz scenester lo-fi voluptate, tote bag irony bicycle rights pariatur vero Vice freegan wayfarers exercitation nisi shoreditch. Chambray tofu vero sed. Street art swag literally leggings, Cosby sweater mixtape PBR lomo Banksy non in pitchfork ennui McSweeney’s selfies. Odd Future Banksy non authentic.&lt;/p&gt;

&lt;p&gt;Aliquip enim artisan dolor post-ironic. Pug tote bag Marfa, deserunt pour-over Portland wolf eu odio intelligentsia american apparel ugh ea. Sunt viral et, 3 wolf moon gastropub pug id. Id fashion axe est typewriter, mlkshk Portland art party aute brunch. Sint pork belly Cosby sweater, deep v mumblecore kitsch american apparel. Try-hard direct trade tumblr sint skateboard. Adipisicing bitters excepteur biodiesel, pickled gastropub aute veniam.&lt;/p&gt;</content><category term="sample post" /><category term="readability" /><category term="test" /><summary type="html">A ton of text to test readability.</summary></entry></feed>
